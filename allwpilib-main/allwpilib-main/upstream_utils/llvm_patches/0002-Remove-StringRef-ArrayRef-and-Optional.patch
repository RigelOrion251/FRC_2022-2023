From afca62cd2f1616bcf2e648dc121a057d59168424 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Sat, 7 May 2022 22:09:18 -0400
Subject: [PATCH 02/28] Remove StringRef, ArrayRef, and Optional

---
 llvm/include/llvm/ADT/PointerUnion.h          |  1 -
 llvm/include/llvm/ADT/SmallSet.h              | 13 ++--
 llvm/include/llvm/ADT/SmallString.h           | 77 ++++++++++---------
 llvm/include/llvm/ADT/StringMap.h             | 34 ++++----
 llvm/include/llvm/ADT/StringMapEntry.h        | 25 +++---
 llvm/include/llvm/Support/Chrono.h            | 10 +--
 llvm/include/llvm/Support/Compiler.h          |  2 +-
 llvm/include/llvm/Support/ConvertUTF.h        | 28 ++++---
 llvm/include/llvm/Support/DJB.h               |  6 +-
 llvm/include/llvm/Support/ErrorHandling.h     |  9 +--
 .../llvm/Support/SmallVectorMemoryBuffer.h    |  6 +-
 llvm/include/llvm/Support/VersionTuple.h      | 20 ++---
 .../llvm/Support/Windows/WindowsSupport.h     |  4 +-
 llvm/include/llvm/Support/raw_ostream.h       | 51 ++++++------
 llvm/lib/Support/ConvertUTFWrapper.cpp        | 32 ++++----
 llvm/lib/Support/ErrorHandling.cpp            | 13 ++--
 llvm/lib/Support/SmallVector.cpp              |  5 +-
 llvm/lib/Support/StringMap.cpp                | 12 +--
 llvm/lib/Support/raw_ostream.cpp              | 25 +++---
 llvm/unittests/ADT/DenseMapTest.cpp           | 25 ------
 llvm/unittests/ADT/FunctionExtrasTest.cpp     | 12 +--
 llvm/unittests/ADT/HashingTest.cpp            |  2 +-
 llvm/unittests/ADT/SmallPtrSetTest.cpp        |  1 -
 llvm/unittests/ADT/SmallStringTest.cpp        | 50 ++++++------
 llvm/unittests/ADT/SmallVectorTest.cpp        | 20 +----
 llvm/unittests/ADT/StringMapTest.cpp          | 32 ++++----
 llvm/unittests/Support/ConvertUTFTest.cpp     | 37 +++++----
 27 files changed, 248 insertions(+), 304 deletions(-)

diff --git a/llvm/include/llvm/ADT/PointerUnion.h b/llvm/include/llvm/ADT/PointerUnion.h
index 04d566bbc..1d4cc747c 100644
--- a/llvm/include/llvm/ADT/PointerUnion.h
+++ b/llvm/include/llvm/ADT/PointerUnion.h
@@ -17,7 +17,6 @@
 
 #include "llvm/ADT/DenseMapInfo.h"
 #include "llvm/ADT/PointerIntPair.h"
-#include "llvm/ADT/STLExtras.h"
 #include "llvm/Support/PointerLikeTypeTraits.h"
 #include <algorithm>
 #include <cassert>
diff --git a/llvm/include/llvm/ADT/SmallSet.h b/llvm/include/llvm/ADT/SmallSet.h
index 0eed85449..bfe93e997 100644
--- a/llvm/include/llvm/ADT/SmallSet.h
+++ b/llvm/include/llvm/ADT/SmallSet.h
@@ -14,15 +14,14 @@
 #ifndef LLVM_ADT_SMALLSET_H
 #define LLVM_ADT_SMALLSET_H
 
-#include "llvm/ADT/None.h"
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/iterator.h"
 #include "llvm/Support/Compiler.h"
 #include "llvm/Support/type_traits.h"
 #include <cstddef>
 #include <functional>
+#include <optional>
 #include <set>
 #include <type_traits>
 #include <utility>
@@ -179,16 +178,16 @@ public:
   /// concept.
   // FIXME: Add iterators that abstract over the small and large form, and then
   // return those here.
-  std::pair<NoneType, bool> insert(const T &V) {
+  std::pair<std::nullopt_t, bool> insert(const T &V) {
     if (!isSmall())
-      return std::make_pair(None, Set.insert(V).second);
+      return std::make_pair(std::nullopt, Set.insert(V).second);
 
     VIterator I = vfind(V);
     if (I != Vector.end())    // Don't reinsert if it already exists.
-      return std::make_pair(None, false);
+      return std::make_pair(std::nullopt, false);
     if (Vector.size() < N) {
       Vector.push_back(V);
-      return std::make_pair(None, true);
+      return std::make_pair(std::nullopt, true);
     }
 
     // Otherwise, grow from vector to set.
@@ -197,7 +196,7 @@ public:
       Vector.pop_back();
     }
     Set.insert(V);
-    return std::make_pair(None, true);
+    return std::make_pair(std::nullopt, true);
   }
 
   template <typename IterT>
diff --git a/llvm/include/llvm/ADT/SmallString.h b/llvm/include/llvm/ADT/SmallString.h
index 874968f0a..50cbdade4 100644
--- a/llvm/include/llvm/ADT/SmallString.h
+++ b/llvm/include/llvm/ADT/SmallString.h
@@ -15,8 +15,9 @@
 #define LLVM_ADT_SMALLSTRING_H
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
 #include <cstddef>
+#include <string>
+#include <string_view>
 
 namespace llvm {
 
@@ -28,11 +29,11 @@ public:
   /// Default ctor - Initialize to empty.
   SmallString() = default;
 
-  /// Initialize from a StringRef.
-  SmallString(StringRef S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}
+  /// Initialize from a std::string_view.
+  SmallString(std::string_view S) : SmallVector<char, InternalLen>(S.begin(), S.end()) {}
 
-  /// Initialize by concatenating a list of StringRefs.
-  SmallString(std::initializer_list<StringRef> Refs)
+  /// Initialize by concatenating a list of std::string_views.
+  SmallString(std::initializer_list<std::string_view> Refs)
       : SmallVector<char, InternalLen>() {
     this->append(Refs);
   }
@@ -47,13 +48,13 @@ public:
 
   using SmallVector<char, InternalLen>::assign;
 
-  /// Assign from a StringRef.
-  void assign(StringRef RHS) {
+  /// Assign from a std::string_view.
+  void assign(std::string_view RHS) {
     SmallVectorImpl<char>::assign(RHS.begin(), RHS.end());
   }
 
-  /// Assign from a list of StringRefs.
-  void assign(std::initializer_list<StringRef> Refs) {
+  /// Assign from a list of std::string_views.
+  void assign(std::initializer_list<std::string_view> Refs) {
     this->clear();
     append(Refs);
   }
@@ -64,19 +65,19 @@ public:
 
   using SmallVector<char, InternalLen>::append;
 
-  /// Append from a StringRef.
-  void append(StringRef RHS) {
+  /// Append from a std::string_view.
+  void append(std::string_view RHS) {
     SmallVectorImpl<char>::append(RHS.begin(), RHS.end());
   }
 
-  /// Append from a list of StringRefs.
-  void append(std::initializer_list<StringRef> Refs) {
+  /// Append from a list of std::string_views.
+  void append(std::initializer_list<std::string_view> Refs) {
     size_t CurrentSize = this->size();
     size_t SizeNeeded = CurrentSize;
-    for (const StringRef &Ref : Refs)
+    for (const std::string_view &Ref : Refs)
       SizeNeeded += Ref.size();
     this->resize_for_overwrite(SizeNeeded);
-    for (const StringRef &Ref : Refs) {
+    for (const std::string_view &Ref : Refs) {
       std::copy(Ref.begin(), Ref.end(), this->begin() + CurrentSize);
       CurrentSize += Ref.size();
     }
@@ -89,29 +90,29 @@ public:
 
   /// Check for string equality.  This is more efficient than compare() when
   /// the relative ordering of inequal strings isn't needed.
-  bool equals(StringRef RHS) const {
+  bool equals(std::string_view RHS) const {
     return str().equals(RHS);
   }
 
   /// Check for string equality, ignoring case.
-  bool equals_insensitive(StringRef RHS) const {
+  bool equals_insensitive(std::string_view RHS) const {
     return str().equals_insensitive(RHS);
   }
 
   /// Compare two strings; the result is -1, 0, or 1 if this string is
   /// lexicographically less than, equal to, or greater than the \p RHS.
-  int compare(StringRef RHS) const {
+  int compare(std::string_view RHS) const {
     return str().compare(RHS);
   }
 
   /// compare_insensitive - Compare two strings, ignoring case.
-  int compare_insensitive(StringRef RHS) const {
+  int compare_insensitive(std::string_view RHS) const {
     return str().compare_insensitive(RHS);
   }
 
   /// compare_numeric - Compare two strings, treating sequences of digits as
   /// numbers.
-  int compare_numeric(StringRef RHS) const {
+  int compare_numeric(std::string_view RHS) const {
     return str().compare_numeric(RHS);
   }
 
@@ -120,12 +121,12 @@ public:
   /// @{
 
   /// startswith - Check if this string starts with the given \p Prefix.
-  bool startswith(StringRef Prefix) const {
+  bool startswith(std::string_view Prefix) const {
     return str().startswith(Prefix);
   }
 
   /// endswith - Check if this string ends with the given \p Suffix.
-  bool endswith(StringRef Suffix) const {
+  bool endswith(std::string_view Suffix) const {
     return str().endswith(Suffix);
   }
 
@@ -145,7 +146,7 @@ public:
   ///
   /// \returns The index of the first occurrence of \p Str, or npos if not
   /// found.
-  size_t find(StringRef Str, size_t From = 0) const {
+  size_t find(std::string_view Str, size_t From = 0) const {
     return str().find(Str, From);
   }
 
@@ -153,7 +154,7 @@ public:
   ///
   /// \returns The index of the last occurrence of \p C, or npos if not
   /// found.
-  size_t rfind(char C, size_t From = StringRef::npos) const {
+  size_t rfind(char C, size_t From = std::string_view::npos) const {
     return str().rfind(C, From);
   }
 
@@ -161,7 +162,7 @@ public:
   ///
   /// \returns The index of the last occurrence of \p Str, or npos if not
   /// found.
-  size_t rfind(StringRef Str) const {
+  size_t rfind(std::string_view Str) const {
     return str().rfind(Str);
   }
 
@@ -175,7 +176,7 @@ public:
   /// not found.
   ///
   /// Complexity: O(size() + Chars.size())
-  size_t find_first_of(StringRef Chars, size_t From = 0) const {
+  size_t find_first_of(std::string_view Chars, size_t From = 0) const {
     return str().find_first_of(Chars, From);
   }
 
@@ -189,13 +190,13 @@ public:
   /// \p Chars, or npos if not found.
   ///
   /// Complexity: O(size() + Chars.size())
-  size_t find_first_not_of(StringRef Chars, size_t From = 0) const {
+  size_t find_first_not_of(std::string_view Chars, size_t From = 0) const {
     return str().find_first_not_of(Chars, From);
   }
 
   /// Find the last character in the string that is \p C, or npos if not
   /// found.
-  size_t find_last_of(char C, size_t From = StringRef::npos) const {
+  size_t find_last_of(char C, size_t From = std::string_view::npos) const {
     return str().find_last_of(C, From);
   }
 
@@ -204,7 +205,7 @@ public:
   ///
   /// Complexity: O(size() + Chars.size())
   size_t find_last_of(
-      StringRef Chars, size_t From = StringRef::npos) const {
+      std::string_view Chars, size_t From = std::string_view::npos) const {
     return str().find_last_of(Chars, From);
   }
 
@@ -219,7 +220,7 @@ public:
 
   /// Return the number of non-overlapped occurrences of \p Str in the
   /// string.
-  size_t count(StringRef Str) const {
+  size_t count(std::string_view Str) const {
     return str().count(Str);
   }
 
@@ -236,7 +237,7 @@ public:
   /// \param N The number of characters to included in the substring. If \p N
   /// exceeds the number of characters remaining in the string, the string
   /// suffix (starting with \p Start) will be returned.
-  StringRef substr(size_t Start, size_t N = StringRef::npos) const {
+  std::string_view substr(size_t Start, size_t N = std::string_view::npos) const {
     return str().substr(Start, N);
   }
 
@@ -250,14 +251,14 @@ public:
   /// substring. If this is npos, or less than \p Start, or exceeds the
   /// number of characters remaining in the string, the string suffix
   /// (starting with \p Start) will be returned.
-  StringRef slice(size_t Start, size_t End) const {
+  std::string_view slice(size_t Start, size_t End) const {
     return str().slice(Start, End);
   }
 
   // Extra methods.
 
-  /// Explicit conversion to StringRef.
-  StringRef str() const { return StringRef(this->data(), this->size()); }
+  /// Explicit conversion to std::string_view.
+  std::string_view str() const { return std::string_view(this->begin(), this->size()); }
 
   // TODO: Make this const, if it's safe...
   const char* c_str() {
@@ -266,20 +267,20 @@ public:
     return this->data();
   }
 
-  /// Implicit conversion to StringRef.
-  operator StringRef() const { return str(); }
+  /// Implicit conversion to std::string_view.
+  operator std::string_view() const { return str(); }
 
   explicit operator std::string() const {
     return std::string(this->data(), this->size());
   }
 
   // Extra operators.
-  SmallString &operator=(StringRef RHS) {
+  SmallString &operator=(std::string_view RHS) {
     this->assign(RHS);
     return *this;
   }
 
-  SmallString &operator+=(StringRef RHS) {
+  SmallString &operator+=(std::string_view RHS) {
     this->append(RHS.begin(), RHS.end());
     return *this;
   }
diff --git a/llvm/include/llvm/ADT/StringMap.h b/llvm/include/llvm/ADT/StringMap.h
index 23248093c..8747cdb35 100644
--- a/llvm/include/llvm/ADT/StringMap.h
+++ b/llvm/include/llvm/ADT/StringMap.h
@@ -60,12 +60,12 @@ protected:
   /// specified bucket will be non-null.  Otherwise, it will be null.  In either
   /// case, the FullHashValue field of the bucket will be set to the hash value
   /// of the string.
-  unsigned LookupBucketFor(StringRef Key);
+  unsigned LookupBucketFor(std::string_view Key);
 
   /// FindKey - Look up the bucket that contains the specified key. If it exists
   /// in the map, return the bucket number of the key.  Otherwise return -1.
   /// This does not modify the map.
-  int FindKey(StringRef Key) const;
+  int FindKey(std::string_view Key) const;
 
   /// RemoveKey - Remove the specified StringMapEntry from the table, but do not
   /// delete it.  This aborts if the value isn't in the table.
@@ -73,7 +73,7 @@ protected:
 
   /// RemoveKey - Remove the StringMapEntry for the specified key from the
   /// table, returning it.  If the key is not in the table, this returns null.
-  StringMapEntryBase *RemoveKey(StringRef Key);
+  StringMapEntryBase *RemoveKey(std::string_view Key);
 
   /// Allocate the table with the specified number of buckets and otherwise
   /// setup the map as empty.
@@ -126,7 +126,7 @@ public:
       : StringMapImpl(InitialSize, static_cast<unsigned>(sizeof(MapEntryTy))),
         Allocator(A) {}
 
-  StringMap(std::initializer_list<std::pair<StringRef, ValueTy>> List)
+  StringMap(std::initializer_list<std::pair<std::string_view, ValueTy>> List)
       : StringMapImpl(List.size(), static_cast<unsigned>(sizeof(MapEntryTy))) {
     insert(List);
   }
@@ -215,14 +215,14 @@ public:
                       StringMapKeyIterator<ValueTy>(end()));
   }
 
-  iterator find(StringRef Key) {
+  iterator find(std::string_view Key) {
     int Bucket = FindKey(Key);
     if (Bucket == -1)
       return end();
     return iterator(TheTable + Bucket, true);
   }
 
-  const_iterator find(StringRef Key) const {
+  const_iterator find(std::string_view Key) const {
     int Bucket = FindKey(Key);
     if (Bucket == -1)
       return end();
@@ -231,7 +231,7 @@ public:
 
   /// lookup - Return the entry for the specified key, or a default
   /// constructed value if no such entry exists.
-  ValueTy lookup(StringRef Key) const {
+  ValueTy lookup(std::string_view Key) const {
     const_iterator it = find(Key);
     if (it != end())
       return it->second;
@@ -240,10 +240,10 @@ public:
 
   /// Lookup the ValueTy for the \p Key, or create a default constructed value
   /// if the key is not in the map.
-  ValueTy &operator[](StringRef Key) { return try_emplace(Key).first->second; }
+  ValueTy &operator[](std::string_view Key) { return try_emplace(Key).first->second; }
 
   /// count - Return 1 if the element is in the map, 0 otherwise.
-  size_type count(StringRef Key) const { return find(Key) == end() ? 0 : 1; }
+  size_type count(std::string_view Key) const { return find(Key) == end() ? 0 : 1; }
 
   template <typename InputTy>
   size_type count(const StringMapEntry<InputTy> &MapEntry) const {
@@ -293,7 +293,7 @@ public:
   /// isn't already in the map. The bool component of the returned pair is true
   /// if and only if the insertion takes place, and the iterator component of
   /// the pair points to the element with key equivalent to the key of the pair.
-  std::pair<iterator, bool> insert(std::pair<StringRef, ValueTy> KV) {
+  std::pair<iterator, bool> insert(std::pair<std::string_view, ValueTy> KV) {
     return try_emplace(KV.first, std::move(KV.second));
   }
 
@@ -308,14 +308,14 @@ public:
   ///  Inserts elements from initializer list ilist. If multiple elements in
   /// the range have keys that compare equivalent, it is unspecified which
   /// element is inserted
-  void insert(std::initializer_list<std::pair<StringRef, ValueTy>> List) {
+  void insert(std::initializer_list<std::pair<std::string_view, ValueTy>> List) {
     insert(List.begin(), List.end());
   }
 
   /// Inserts an element or assigns to the current element if the key already
   /// exists. The return type is the same as try_emplace.
   template <typename V>
-  std::pair<iterator, bool> insert_or_assign(StringRef Key, V &&Val) {
+  std::pair<iterator, bool> insert_or_assign(std::string_view Key, V &&Val) {
     auto Ret = try_emplace(Key, std::forward<V>(Val));
     if (!Ret.second)
       Ret.first->second = std::forward<V>(Val);
@@ -327,7 +327,7 @@ public:
   /// if and only if the insertion takes place, and the iterator component of
   /// the pair points to the element with key equivalent to the key of the pair.
   template <typename... ArgsTy>
-  std::pair<iterator, bool> try_emplace(StringRef Key, ArgsTy &&... Args) {
+  std::pair<iterator, bool> try_emplace(std::string_view Key, ArgsTy &&... Args) {
     unsigned BucketNo = LookupBucketFor(Key);
     StringMapEntryBase *&Bucket = TheTable[BucketNo];
     if (Bucket && Bucket != getTombstoneVal())
@@ -373,7 +373,7 @@ public:
     V.Destroy(Allocator);
   }
 
-  bool erase(StringRef Key) {
+  bool erase(std::string_view Key) {
     iterator I = find(Key);
     if (I == end())
       return false;
@@ -470,17 +470,17 @@ template <typename ValueTy>
 class StringMapKeyIterator
     : public iterator_adaptor_base<StringMapKeyIterator<ValueTy>,
                                    StringMapConstIterator<ValueTy>,
-                                   std::forward_iterator_tag, StringRef> {
+                                   std::forward_iterator_tag, std::string_view> {
   using base = iterator_adaptor_base<StringMapKeyIterator<ValueTy>,
                                      StringMapConstIterator<ValueTy>,
-                                     std::forward_iterator_tag, StringRef>;
+                                     std::forward_iterator_tag, std::string_view>;
 
 public:
   StringMapKeyIterator() = default;
   explicit StringMapKeyIterator(StringMapConstIterator<ValueTy> Iter)
       : base(std::move(Iter)) {}
 
-  StringRef operator*() const { return this->wrapped()->getKey(); }
+  std::string_view operator*() const { return this->wrapped()->getKey(); }
 };
 
 } // end namespace llvm
diff --git a/llvm/include/llvm/ADT/StringMapEntry.h b/llvm/include/llvm/ADT/StringMapEntry.h
index 6e13c8618..39976a02b 100644
--- a/llvm/include/llvm/ADT/StringMapEntry.h
+++ b/llvm/include/llvm/ADT/StringMapEntry.h
@@ -16,9 +16,8 @@
 #ifndef LLVM_ADT_STRINGMAPENTRY_H
 #define LLVM_ADT_STRINGMAPENTRY_H
 
-#include "llvm/ADT/None.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/STLFunctionalExtras.h"
+#include <optional>
+#include <string_view>
 
 namespace llvm {
 
@@ -37,13 +36,13 @@ protected:
   /// type-erase the allocator and put it in a source file.
   template <typename AllocatorTy>
   static void *allocateWithKey(size_t EntrySize, size_t EntryAlign,
-                               StringRef Key, AllocatorTy &Allocator);
+                               std::string_view Key, AllocatorTy &Allocator);
 };
 
 // Define out-of-line to dissuade inlining.
 template <typename AllocatorTy>
 void *StringMapEntryBase::allocateWithKey(size_t EntrySize, size_t EntryAlign,
-                                          StringRef Key,
+                                          std::string_view Key,
                                           AllocatorTy &Allocator) {
   size_t KeyLength = Key.size();
 
@@ -85,13 +84,13 @@ public:
   void setValue(const ValueTy &V) { second = V; }
 };
 
-template <> class StringMapEntryStorage<NoneType> : public StringMapEntryBase {
+template <> class StringMapEntryStorage<std::nullopt_t> : public StringMapEntryBase {
 public:
-  explicit StringMapEntryStorage(size_t keyLength, NoneType = None)
+  explicit StringMapEntryStorage(size_t keyLength, std::nullopt_t = std::nullopt)
       : StringMapEntryBase(keyLength) {}
   StringMapEntryStorage(StringMapEntryStorage &entry) = delete;
 
-  NoneType getValue() const { return None; }
+  std::nullopt_t getValue() const { return std::nullopt; }
 };
 
 /// StringMapEntry - This is used to represent one value that is inserted into
@@ -102,8 +101,8 @@ class StringMapEntry final : public StringMapEntryStorage<ValueTy> {
 public:
   using StringMapEntryStorage<ValueTy>::StringMapEntryStorage;
 
-  StringRef getKey() const {
-    return StringRef(getKeyData(), this->getKeyLength());
+  std::string_view getKey() const {
+    return std::string_view(getKeyData(), this->getKeyLength());
   }
 
   /// getKeyData - Return the start of the string data that is the key for this
@@ -113,14 +112,14 @@ public:
     return reinterpret_cast<const char *>(this + 1);
   }
 
-  StringRef first() const {
-    return StringRef(getKeyData(), this->getKeyLength());
+  std::string_view first() const {
+    return std::string_view(getKeyData(), this->getKeyLength());
   }
 
   /// Create a StringMapEntry for the specified key construct the value using
   /// \p InitiVals.
   template <typename AllocatorTy, typename... InitTy>
-  static StringMapEntry *Create(StringRef key, AllocatorTy &allocator,
+  static StringMapEntry *Create(std::string_view key, AllocatorTy &allocator,
                                 InitTy &&... initVals) {
     return new (StringMapEntryBase::allocateWithKey(
         sizeof(StringMapEntry), alignof(StringMapEntry), key, allocator))
diff --git a/llvm/include/llvm/Support/Chrono.h b/llvm/include/llvm/Support/Chrono.h
index 9c2bd45d2..a7dea19d9 100644
--- a/llvm/include/llvm/Support/Chrono.h
+++ b/llvm/include/llvm/Support/Chrono.h
@@ -70,7 +70,7 @@ raw_ostream &operator<<(raw_ostream &OS, sys::TimePoint<> TP);
 template <>
 struct format_provider<sys::TimePoint<>> {
   static void format(const sys::TimePoint<> &TP, llvm::raw_ostream &OS,
-                     StringRef Style);
+                     std::string_view Style);
 };
 
 namespace detail {
@@ -122,7 +122,7 @@ private:
     return duration_cast<duration<InternalRep, AsPeriod>>(D).count();
   }
 
-  static std::pair<InternalRep, StringRef> consumeUnit(StringRef &Style,
+  static std::pair<InternalRep, std::string_view> consumeUnit(std::string_view &Style,
                                                         const Dur &D) {
     using namespace std::chrono;
     if (Style.consume_front("ns"))
@@ -140,7 +140,7 @@ private:
     return {D.count(), detail::unit<Period>::value};
   }
 
-  static bool consumeShowUnit(StringRef &Style) {
+  static bool consumeShowUnit(std::string_view &Style) {
     if (Style.empty())
       return true;
     if (Style.consume_front("-"))
@@ -152,9 +152,9 @@ private:
   }
 
 public:
-  static void format(const Dur &D, llvm::raw_ostream &Stream, StringRef Style) {
+  static void format(const Dur &D, llvm::raw_ostream &Stream, std::string_view Style) {
     InternalRep count;
-    StringRef unit;
+    std::string_view unit;
     std::tie(count, unit) = consumeUnit(Style, D);
     bool show_unit = consumeShowUnit(Style);
 
diff --git a/llvm/include/llvm/Support/Compiler.h b/llvm/include/llvm/Support/Compiler.h
index 80b2dfaec..f5d726ec8 100644
--- a/llvm/include/llvm/Support/Compiler.h
+++ b/llvm/include/llvm/Support/Compiler.h
@@ -312,7 +312,7 @@
 #endif
 
 /// LLVM_GSL_POINTER - Apply this to non-owning classes like
-/// StringRef to enable lifetime warnings.
+/// std::string_view to enable lifetime warnings.
 #if LLVM_HAS_CPP_ATTRIBUTE(gsl::Pointer)
 #define LLVM_GSL_POINTER [[gsl::Pointer]]
 #else
diff --git a/llvm/include/llvm/Support/ConvertUTF.h b/llvm/include/llvm/Support/ConvertUTF.h
index 374cdb907..7f1527f51 100644
--- a/llvm/include/llvm/Support/ConvertUTF.h
+++ b/llvm/include/llvm/Support/ConvertUTF.h
@@ -89,12 +89,12 @@
 #ifndef LLVM_SUPPORT_CONVERTUTF_H
 #define LLVM_SUPPORT_CONVERTUTF_H
 
+#include "wpi/span.h"
+
 #include <cstddef>
 #include <string>
-
-#if defined(_WIN32)
+#include <string_view>
 #include <system_error>
-#endif
 
 // Wrap everything in namespace llvm so that programs can link with llvm and
 // their own version of the unicode libraries.
@@ -183,12 +183,10 @@ unsigned getNumBytesForUTF8(UTF8 firstByte);
 /*************************************************************************/
 /* Below are LLVM-specific wrappers of the functions above. */
 
-template <typename T> class ArrayRef;
 template <typename T> class SmallVectorImpl;
-class StringRef;
 
 /**
- * Convert an UTF8 StringRef to UTF8, UTF16, or UTF32 depending on
+ * Convert an UTF8 string_view to UTF8, UTF16, or UTF32 depending on
  * WideCharWidth. The converted data is written to ResultPtr, which needs to
  * point to at least WideCharWidth * (Source.Size() + 1) bytes. On success,
  * ResultPtr will point one after the end of the copied string. On failure,
@@ -196,14 +194,14 @@ class StringRef;
  * the first character which could not be converted.
  * \return true on success.
  */
-bool ConvertUTF8toWide(unsigned WideCharWidth, llvm::StringRef Source,
+bool ConvertUTF8toWide(unsigned WideCharWidth, std::string_view Source,
                        char *&ResultPtr, const UTF8 *&ErrorPtr);
 
 /**
-* Converts a UTF-8 StringRef to a std::wstring.
+* Converts a UTF-8 string_view to a std::wstring.
 * \return true on success.
 */
-bool ConvertUTF8toWide(llvm::StringRef Source, std::wstring &Result);
+bool ConvertUTF8toWide(std::string_view Source, std::wstring &Result);
 
 /**
 * Converts a UTF-8 C-string to a std::wstring.
@@ -261,7 +259,7 @@ inline ConversionResult convertUTF8Sequence(const UTF8 **source,
  * Returns true if a blob of text starts with a UTF-16 big or little endian byte
  * order mark.
  */
-bool hasUTF16ByteOrderMark(ArrayRef<char> SrcBytes);
+bool hasUTF16ByteOrderMark(span<const char> SrcBytes);
 
 /**
  * Converts a stream of raw bytes assumed to be UTF16 into a UTF8 std::string.
@@ -270,7 +268,7 @@ bool hasUTF16ByteOrderMark(ArrayRef<char> SrcBytes);
  * \param [out] Out Converted UTF-8 is stored here on success.
  * \returns true on success
  */
-bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
+bool convertUTF16ToUTF8String(span<const char> SrcBytes, std::string &Out);
 
 /**
 * Converts a UTF16 string into a UTF8 std::string.
@@ -279,22 +277,22 @@ bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out);
 * \param [out] Out Converted UTF-8 is stored here on success.
 * \returns true on success
 */
-bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out);
+bool convertUTF16ToUTF8String(span<const UTF16> Src, std::string &Out);
 
 /**
  * Converts a UTF-8 string into a UTF-16 string with native endianness.
  *
  * \returns true on success
  */
-bool convertUTF8ToUTF16String(StringRef SrcUTF8,
+bool convertUTF8ToUTF16String(std::string_view SrcUTF8,
                               SmallVectorImpl<UTF16> &DstUTF16);
 
 #if defined(_WIN32)
 namespace sys {
 namespace windows {
-std::error_code UTF8ToUTF16(StringRef utf8, SmallVectorImpl<wchar_t> &utf16);
+std::error_code UTF8ToUTF16(std::string_view utf8, SmallVectorImpl<wchar_t> &utf16);
 /// Convert to UTF16 from the current code page used in the system
-std::error_code CurCPToUTF16(StringRef utf8, SmallVectorImpl<wchar_t> &utf16);
+std::error_code CurCPToUTF16(std::string_view utf8, SmallVectorImpl<wchar_t> &utf16);
 std::error_code UTF16ToUTF8(const wchar_t *utf16, size_t utf16_len,
                             SmallVectorImpl<char> &utf8);
 /// Convert from UTF16 to the current code page used in the system
diff --git a/llvm/include/llvm/Support/DJB.h b/llvm/include/llvm/Support/DJB.h
index 8a04a324a..8737cd144 100644
--- a/llvm/include/llvm/Support/DJB.h
+++ b/llvm/include/llvm/Support/DJB.h
@@ -13,13 +13,13 @@
 #ifndef LLVM_SUPPORT_DJB_H
 #define LLVM_SUPPORT_DJB_H
 
-#include "llvm/ADT/StringRef.h"
+#include <string_view>
 
 namespace llvm {
 
 /// The Bernstein hash function used by the DWARF accelerator tables.
-inline uint32_t djbHash(StringRef Buffer, uint32_t H = 5381) {
-  for (unsigned char C : Buffer.bytes())
+inline uint32_t djbHash(std::string_view Buffer, uint32_t H = 5381) {
+  for (unsigned char C : Buffer)
     H = (H << 5) + H + C;
   return H;
 }
diff --git a/llvm/include/llvm/Support/ErrorHandling.h b/llvm/include/llvm/Support/ErrorHandling.h
index 6791df6be..3f726d40b 100644
--- a/llvm/include/llvm/Support/ErrorHandling.h
+++ b/llvm/include/llvm/Support/ErrorHandling.h
@@ -15,10 +15,10 @@
 #define LLVM_SUPPORT_ERRORHANDLING_H
 
 #include "llvm/Support/Compiler.h"
+#include <string>
+#include <string_view>
 
 namespace llvm {
-  class StringRef;
-  class Twine;
 
   /// An error handler callback.
   typedef void (*fatal_error_handler_t)(void *user_data,
@@ -67,12 +67,11 @@ namespace llvm {
 /// standard error, followed by a newline.
 /// After the error handler is called this function will call abort(), it
 /// does not return.
-/// NOTE: The std::string variant was removed to avoid a <string> dependency.
 [[noreturn]] void report_fatal_error(const char *reason,
                                      bool gen_crash_diag = true);
-[[noreturn]] void report_fatal_error(StringRef reason,
+[[noreturn]] void report_fatal_error(const std::string &reason,
                                      bool gen_crash_diag = true);
-[[noreturn]] void report_fatal_error(const Twine &reason,
+[[noreturn]] void report_fatal_error(std::string_view reason,
                                      bool gen_crash_diag = true);
 
 /// Installs a new bad alloc error handler that should be used whenever a
diff --git a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
index f7f2d4e54..b5e321b5f 100644
--- a/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
+++ b/llvm/include/llvm/Support/SmallVectorMemoryBuffer.h
@@ -35,8 +35,8 @@ public:
                                 RequiresNullTerminator) {}
 
   /// Construct a named SmallVectorMemoryBuffer from the given SmallVector
-  /// r-value and StringRef.
-  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, StringRef Name,
+  /// r-value and std::string_view.
+  SmallVectorMemoryBuffer(SmallVectorImpl<char> &&SV, std::string_view Name,
                           bool RequiresNullTerminator = true)
       : SV(std::move(SV)), BufferName(std::string(Name)) {
     if (RequiresNullTerminator) {
@@ -49,7 +49,7 @@ public:
   // Key function.
   ~SmallVectorMemoryBuffer() override;
 
-  StringRef getBufferIdentifier() const override { return BufferName; }
+  std::string_view getBufferIdentifier() const override { return BufferName; }
 
   BufferKind getBufferKind() const override { return MemoryBuffer_Malloc; }
 
diff --git a/llvm/include/llvm/Support/VersionTuple.h b/llvm/include/llvm/Support/VersionTuple.h
index 1a1072d22..3d6573bf5 100644
--- a/llvm/include/llvm/Support/VersionTuple.h
+++ b/llvm/include/llvm/Support/VersionTuple.h
@@ -16,14 +16,13 @@
 
 #include "llvm/ADT/DenseMapInfo.h"
 #include "llvm/ADT/Hashing.h"
-#include "llvm/ADT/Optional.h"
 #include "llvm/Support/HashBuilder.h"
+#include <optional>
 #include <string>
 #include <tuple>
 
 namespace llvm {
 class raw_ostream;
-class StringRef;
 
 /// Represents a version number in the form major[.minor[.subminor[.build]]].
 class VersionTuple {
@@ -70,23 +69,23 @@ public:
   unsigned getMajor() const { return Major; }
 
   /// Retrieve the minor version number, if provided.
-  Optional<unsigned> getMinor() const {
+  std::optional<unsigned> getMinor() const {
     if (!HasMinor)
-      return None;
+      return std::nullopt;
     return Minor;
   }
 
   /// Retrieve the subminor version number, if provided.
-  Optional<unsigned> getSubminor() const {
+  std::optional<unsigned> getSubminor() const {
     if (!HasSubminor)
-      return None;
+      return std::nullopt;
     return Subminor;
   }
 
   /// Retrieve the build version number, if provided.
-  Optional<unsigned> getBuild() const {
+  std::optional<unsigned> getBuild() const {
     if (!HasBuild)
-      return None;
+      return std::nullopt;
     return Build;
   }
 
@@ -173,11 +172,6 @@ public:
 
   /// Retrieve a string representation of the version number.
   std::string getAsString() const;
-
-  /// Try to parse the given string as a version number.
-  /// \returns \c true if the string does not match the regular expression
-  ///   [0-9]+(\.[0-9]+){0,3}
-  bool tryParse(StringRef string);
 };
 
 /// Print a version number.
diff --git a/llvm/include/llvm/Support/Windows/WindowsSupport.h b/llvm/include/llvm/Support/Windows/WindowsSupport.h
index 917822678..180803fbd 100644
--- a/llvm/include/llvm/Support/Windows/WindowsSupport.h
+++ b/llvm/include/llvm/Support/Windows/WindowsSupport.h
@@ -35,8 +35,6 @@
 
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringExtras.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Config/llvm-config.h" // Get build system configuration settings
 #include "llvm/Support/Allocator.h"
 #include "llvm/Support/Chrono.h"
@@ -71,7 +69,7 @@ bool MakeErrMsg(std::string *ErrMsg, const std::string &prefix);
 [[noreturn]] inline void ReportLastErrorFatal(const char *Msg) {
   std::string ErrMsg;
   MakeErrMsg(&ErrMsg, Msg);
-  llvm::report_fatal_error(Twine(ErrMsg));
+  llvm::report_fatal_error(ErrMsg);
 }
 
 template <typename HandleTraits>
diff --git a/llvm/include/llvm/Support/raw_ostream.h b/llvm/include/llvm/Support/raw_ostream.h
index 58adb41cb..9a1dd7a60 100644
--- a/llvm/include/llvm/Support/raw_ostream.h
+++ b/llvm/include/llvm/Support/raw_ostream.h
@@ -14,9 +14,7 @@
 #define LLVM_SUPPORT_RAW_OSTREAM_H
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/StringRef.h"
-#include "llvm/ADT/Optional.h"
-#include "llvm/Support/DataTypes.h"
+#include "llvm/ADT/span.h"
 #include <cassert>
 #include <cstddef>
 #include <cstdint>
@@ -210,7 +208,22 @@ public:
     return *this;
   }
 
-  raw_ostream &operator<<(StringRef Str) {
+  raw_ostream &operator<<(span<const uint8_t> Arr) {
+    // Inline fast path, particularly for arrays with a known length.
+    size_t Size = Arr.size();
+
+    // Make sure we can use the fast path.
+    if (Size > (size_t)(OutBufEnd - OutBufCur))
+      return write(Arr.data(), Size);
+
+    if (Size) {
+      memcpy(OutBufCur, Arr.data(), Size);
+      OutBufCur += Size;
+    }
+    return *this;
+  }
+
+  raw_ostream &operator<<(std::string_view Str) {
     // Inline fast path, particularly for strings with a known length.
     size_t Size = Str.size();
 
@@ -229,7 +242,7 @@ public:
     // Inline fast path, particularly for constant strings where a sufficiently
     // smart compiler will simplify strlen.
 
-    return this->operator<<(StringRef(Str));
+    return this->operator<<(std::string_view(Str));
   }
 
   raw_ostream &operator<<(const std::string &Str) {
@@ -237,12 +250,6 @@ public:
     return write(Str.data(), Str.length());
   }
 
-#if __cplusplus > 201402L
-  raw_ostream &operator<<(const std::string_view &Str) {
-    return write(Str.data(), Str.length());
-  }
-#endif
-
   raw_ostream &operator<<(const SmallVectorImpl<char> &Str) {
     return write(Str.data(), Str.size());
   }
@@ -275,7 +282,7 @@ public:
 
   /// Output \p Str, turning '\\', '\t', '\n', '"', and anything that doesn't
   /// satisfy llvm::isPrint into an escape sequence.
-  raw_ostream &write_escaped(StringRef Str, bool UseHexEscapes = false);
+  raw_ostream &write_escaped(std::string_view Str, bool UseHexEscapes = false);
 
   raw_ostream &write(unsigned char C);
   raw_ostream &write(const char *Ptr, size_t Size);
@@ -446,7 +453,7 @@ class raw_fd_ostream : public raw_pwrite_stream {
   bool ShouldClose;
   bool SupportsSeeking = false;
   bool IsRegularFile = false;
-  mutable Optional<bool> HasColors;
+  mutable std::optional<bool> HasColors;
 
 #ifdef _WIN32
   /// True if this fd refers to a Windows console device. Mintty and other
@@ -491,14 +498,14 @@ public:
   /// As a special case, if Filename is "-", then the stream will use
   /// STDOUT_FILENO instead of opening a file. This will not close the stdout
   /// descriptor.
-  raw_fd_ostream(StringRef Filename, std::error_code &EC);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC);
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::FileAccess Access);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::OpenFlags Flags);
-  raw_fd_ostream(StringRef Filename, std::error_code &EC,
+  raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                  sys::fs::OpenFlags Flags);
 
@@ -603,7 +610,7 @@ public:
   /// Open the specified file for reading/writing/seeking. If an error occurs,
   /// information about the error is put into EC, and the stream should be
   /// immediately destroyed.
-  raw_fd_stream(StringRef Filename, std::error_code &EC);
+  raw_fd_stream(std::string_view Filename, std::error_code &EC);
 
   /// This reads the \p Size bytes into a buffer pointed by \p Ptr.
   ///
@@ -683,8 +690,8 @@ public:
 
   void flush() = delete;
 
-  /// Return a StringRef for the vector contents.
-  StringRef str() const { return StringRef(OS.data(), OS.size()); }
+  /// Return a std::string_view for the vector contents.
+  std::string_view str() const { return std::string_view(OS.data(), OS.size()); }
 
   void reserveExtraSpace(uint64_t ExtraSize) override {
     OS.reserve(tell() + ExtraSize);
@@ -741,7 +748,7 @@ class Error;
 /// for other names. For raw_fd_ostream instances, the stream writes to
 /// a temporary file. The final output file is atomically replaced with the
 /// temporary file after the \p Write function is finished.
-Error writeToOutput(StringRef OutputFileName,
+Error writeToOutput(std::string_view OutputFileName,
                     std::function<Error(raw_ostream &)> Write);
 
 } // end namespace llvm
diff --git a/llvm/lib/Support/ConvertUTFWrapper.cpp b/llvm/lib/Support/ConvertUTFWrapper.cpp
index 392c4c489..396ab0c65 100644
--- a/llvm/lib/Support/ConvertUTFWrapper.cpp
+++ b/llvm/lib/Support/ConvertUTFWrapper.cpp
@@ -6,24 +6,24 @@
 //
 //===----------------------------------------------------------------------===//
 
-#include "llvm/ADT/ArrayRef.h"
-#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/span.h"
 #include "llvm/Support/ConvertUTF.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/SwapByteOrder.h"
 #include <string>
+#include <string_view>
 #include <vector>
 
 namespace llvm {
 
-bool ConvertUTF8toWide(unsigned WideCharWidth, llvm::StringRef Source,
+bool ConvertUTF8toWide(unsigned WideCharWidth, std::string_view Source,
                        char *&ResultPtr, const UTF8 *&ErrorPtr) {
   assert(WideCharWidth == 1 || WideCharWidth == 2 || WideCharWidth == 4);
   ConversionResult result = conversionOK;
   // Copy the character span over.
   if (WideCharWidth == 1) {
-    const UTF8 *Pos = reinterpret_cast<const UTF8*>(Source.begin());
-    if (!isLegalUTF8String(&Pos, reinterpret_cast<const UTF8*>(Source.end()))) {
+    const UTF8 *Pos = reinterpret_cast<const UTF8*>(Source.data());
+    if (!isLegalUTF8String(&Pos, reinterpret_cast<const UTF8*>(Source.data() + Source.size()))) {
       result = sourceIllegal;
       ErrorPtr = Pos;
     } else {
@@ -77,13 +77,13 @@ bool ConvertCodePointToUTF8(unsigned Source, char *&ResultPtr) {
   return true;
 }
 
-bool hasUTF16ByteOrderMark(ArrayRef<char> S) {
+bool hasUTF16ByteOrderMark(span<const char> S) {
   return (S.size() >= 2 &&
           ((S[0] == '\xff' && S[1] == '\xfe') ||
            (S[0] == '\xfe' && S[1] == '\xff')));
 }
 
-bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
+bool convertUTF16ToUTF8String(span<const char> SrcBytes, std::string &Out) {
   assert(Out.empty());
 
   // Error out on an uneven byte count.
@@ -134,14 +134,14 @@ bool convertUTF16ToUTF8String(ArrayRef<char> SrcBytes, std::string &Out) {
   return true;
 }
 
-bool convertUTF16ToUTF8String(ArrayRef<UTF16> Src, std::string &Out)
+bool convertUTF16ToUTF8String(span<const UTF16> Src, std::string &Out)
 {
   return convertUTF16ToUTF8String(
-      llvm::ArrayRef<char>(reinterpret_cast<const char *>(Src.data()),
+      span<const char>(reinterpret_cast<const char *>(Src.data()),
       Src.size() * sizeof(UTF16)), Out);
 }
 
-bool convertUTF8ToUTF16String(StringRef SrcUTF8,
+bool convertUTF8ToUTF16String(std::string_view SrcUTF8,
                               SmallVectorImpl<UTF16> &DstUTF16) {
   assert(DstUTF16.empty());
 
@@ -152,8 +152,8 @@ bool convertUTF8ToUTF16String(StringRef SrcUTF8,
     return true;
   }
 
-  const UTF8 *Src = reinterpret_cast<const UTF8 *>(SrcUTF8.begin());
-  const UTF8 *SrcEnd = reinterpret_cast<const UTF8 *>(SrcUTF8.end());
+  const UTF8 *Src = reinterpret_cast<const UTF8 *>(SrcUTF8.data());
+  const UTF8 *SrcEnd = reinterpret_cast<const UTF8 *>(SrcUTF8.data() + SrcUTF8.size());
 
   // Allocate the same number of UTF-16 code units as UTF-8 code units. Encoding
   // as UTF-16 should always require the same amount or less code units than the
@@ -184,7 +184,7 @@ static_assert(sizeof(wchar_t) == 1 || sizeof(wchar_t) == 2 ||
               "Expected wchar_t to be 1, 2, or 4 bytes");
 
 template <typename TResult>
-static inline bool ConvertUTF8toWideInternal(llvm::StringRef Source,
+static inline bool ConvertUTF8toWideInternal(std::string_view Source,
                                              TResult &Result) {
   // Even in the case of UTF-16, the number of bytes in a UTF-8 string is
   // at least as large as the number of elements in the resulting wide
@@ -200,7 +200,7 @@ static inline bool ConvertUTF8toWideInternal(llvm::StringRef Source,
   return true;
 }
 
-bool ConvertUTF8toWide(llvm::StringRef Source, std::wstring &Result) {
+bool ConvertUTF8toWide(std::string_view Source, std::wstring &Result) {
   return ConvertUTF8toWideInternal(Source, Result);
 }
 
@@ -209,7 +209,7 @@ bool ConvertUTF8toWide(const char *Source, std::wstring &Result) {
     Result.clear();
     return true;
   }
-  return ConvertUTF8toWide(llvm::StringRef(Source), Result);
+  return ConvertUTF8toWide(std::string_view(Source), Result);
 }
 
 bool convertWideToUTF8(const std::wstring &Source, std::string &Result) {
@@ -224,7 +224,7 @@ bool convertWideToUTF8(const std::wstring &Source, std::string &Result) {
     return true;
   } else if (sizeof(wchar_t) == 2) {
     return convertUTF16ToUTF8String(
-        llvm::ArrayRef<UTF16>(reinterpret_cast<const UTF16 *>(Source.data()),
+        span<const UTF16>(reinterpret_cast<const UTF16 *>(Source.data()),
                               Source.size()),
         Result);
   } else if (sizeof(wchar_t) == 4) {
diff --git a/llvm/lib/Support/ErrorHandling.cpp b/llvm/lib/Support/ErrorHandling.cpp
index 80c0e0043..8ae8fb8b4 100644
--- a/llvm/lib/Support/ErrorHandling.cpp
+++ b/llvm/lib/Support/ErrorHandling.cpp
@@ -14,7 +14,6 @@
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm-c/ErrorHandling.h"
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Config/config.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/Errc.h"
@@ -80,14 +79,14 @@ void llvm::remove_fatal_error_handler() {
 }
 
 void llvm::report_fatal_error(const char *Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
+  report_fatal_error(std::string_view(Reason), GenCrashDiag);
 }
 
-void llvm::report_fatal_error(StringRef Reason, bool GenCrashDiag) {
-  report_fatal_error(Twine(Reason), GenCrashDiag);
+void llvm::report_fatal_error(const std::string &Reason, bool GenCrashDiag) {
+  report_fatal_error(std::string_view(Reason), GenCrashDiag);
 }
 
-void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
+void llvm::report_fatal_error(std::string_view Reason, bool GenCrashDiag) {
   llvm::fatal_error_handler_t handler = nullptr;
   void* handlerData = nullptr;
   {
@@ -101,7 +100,7 @@ void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
   }
 
   if (handler) {
-    handler(handlerData, Reason.str().c_str(), GenCrashDiag);
+    handler(handlerData, std::string{Reason}.c_str(), GenCrashDiag);
   } else {
     // Blast the result out to stderr.  We don't try hard to make sure this
     // succeeds (e.g. handling EINTR) and we can't use errs() here because
@@ -109,7 +108,7 @@ void llvm::report_fatal_error(const Twine &Reason, bool GenCrashDiag) {
     SmallVector<char, 64> Buffer;
     raw_svector_ostream OS(Buffer);
     OS << "LLVM ERROR: " << Reason << "\n";
-    StringRef MessageStr = OS.str();
+    std::string_view MessageStr = OS.str();
     ssize_t written = ::write(2, MessageStr.data(), MessageStr.size());
     (void)written; // If something went wrong, we deliberately just give up.
   }
diff --git a/llvm/lib/Support/SmallVector.cpp b/llvm/lib/Support/SmallVector.cpp
index 8cafbc7fa..8bad715e4 100644
--- a/llvm/lib/Support/SmallVector.cpp
+++ b/llvm/lib/Support/SmallVector.cpp
@@ -11,7 +11,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Support/MemAlloc.h"
 #include <cstdint>
 #ifdef LLVM_ENABLE_EXCEPTIONS
@@ -67,7 +66,7 @@ static void report_size_overflow(size_t MinSize, size_t MaxSize) {
 #ifdef LLVM_ENABLE_EXCEPTIONS
   throw std::length_error(Reason);
 #else
-  report_fatal_error(Twine(Reason));
+  report_fatal_error(Reason);
 #endif
 }
 
@@ -81,7 +80,7 @@ static void report_at_maximum_capacity(size_t MaxSize) {
 #ifdef LLVM_ENABLE_EXCEPTIONS
   throw std::length_error(Reason);
 #else
-  report_fatal_error(Twine(Reason));
+  report_fatal_error(Reason);
 #endif
 }
 
diff --git a/llvm/lib/Support/StringMap.cpp b/llvm/lib/Support/StringMap.cpp
index 012c785b4..317f4ee43 100644
--- a/llvm/lib/Support/StringMap.cpp
+++ b/llvm/lib/Support/StringMap.cpp
@@ -70,7 +70,7 @@ void StringMapImpl::init(unsigned InitSize) {
 /// specified bucket will be non-null.  Otherwise, it will be null.  In either
 /// case, the FullHashValue field of the bucket will be set to the hash value
 /// of the string.
-unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
+unsigned StringMapImpl::LookupBucketFor(std::string_view Name) {
   unsigned HTSize = NumBuckets;
   if (HTSize == 0) { // Hash table unallocated so far?
     init(16);
@@ -110,7 +110,7 @@ unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
       // Do the comparison like this because Name isn't necessarily
       // null-terminated!
       char *ItemStr = (char *)BucketItem + ItemSize;
-      if (Name == StringRef(ItemStr, BucketItem->getKeyLength())) {
+      if (Name == std::string_view(ItemStr, BucketItem->getKeyLength())) {
         // We found a match!
         return BucketNo;
       }
@@ -128,7 +128,7 @@ unsigned StringMapImpl::LookupBucketFor(StringRef Name) {
 /// FindKey - Look up the bucket that contains the specified key. If it exists
 /// in the map, return the bucket number of the key.  Otherwise return -1.
 /// This does not modify the map.
-int StringMapImpl::FindKey(StringRef Key) const {
+int StringMapImpl::FindKey(std::string_view Key) const {
   unsigned HTSize = NumBuckets;
   if (HTSize == 0)
     return -1; // Really empty table?
@@ -154,7 +154,7 @@ int StringMapImpl::FindKey(StringRef Key) const {
       // Do the comparison like this because NameStart isn't necessarily
       // null-terminated!
       char *ItemStr = (char *)BucketItem + ItemSize;
-      if (Key == StringRef(ItemStr, BucketItem->getKeyLength())) {
+      if (Key == std::string_view(ItemStr, BucketItem->getKeyLength())) {
         // We found a match!
         return BucketNo;
       }
@@ -173,14 +173,14 @@ int StringMapImpl::FindKey(StringRef Key) const {
 /// delete it.  This aborts if the value isn't in the table.
 void StringMapImpl::RemoveKey(StringMapEntryBase *V) {
   const char *VStr = (char *)V + ItemSize;
-  StringMapEntryBase *V2 = RemoveKey(StringRef(VStr, V->getKeyLength()));
+  StringMapEntryBase *V2 = RemoveKey(std::string_view(VStr, V->getKeyLength()));
   (void)V2;
   assert(V == V2 && "Didn't find key?");
 }
 
 /// RemoveKey - Remove the StringMapEntry for the specified key from the
 /// table, returning it.  If the key is not in the table, this returns null.
-StringMapEntryBase *StringMapImpl::RemoveKey(StringRef Key) {
+StringMapEntryBase *StringMapImpl::RemoveKey(std::string_view Key) {
   int Bucket = FindKey(Key);
   if (Bucket == -1)
     return nullptr;
diff --git a/llvm/lib/Support/raw_ostream.cpp b/llvm/lib/Support/raw_ostream.cpp
index 69d4fe96b..e4c318eb8 100644
--- a/llvm/lib/Support/raw_ostream.cpp
+++ b/llvm/lib/Support/raw_ostream.cpp
@@ -159,7 +159,7 @@ raw_ostream &raw_ostream::write_uuid(const uuid_t UUID) {
 }
 
 
-raw_ostream &raw_ostream::write_escaped(StringRef Str,
+raw_ostream &raw_ostream::write_escaped(std::string_view Str,
                                         bool UseHexEscapes) {
   for (unsigned char c : Str) {
     switch (c) {
@@ -563,7 +563,7 @@ void format_object_base::home() {
 //  raw_fd_ostream
 //===----------------------------------------------------------------------===//
 
-static int getFD(StringRef Filename, std::error_code &EC,
+static int getFD(std::string_view Filename, std::error_code &EC,
                  sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                  sys::fs::OpenFlags Flags) {
   assert((Access & sys::fs::FA_Write) &&
@@ -589,25 +589,25 @@ static int getFD(StringRef Filename, std::error_code &EC,
   return FD;
 }
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC)
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, sys::fs::FA_Write,
                      sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::CreationDisposition Disp)
     : raw_fd_ostream(Filename, EC, Disp, sys::fs::FA_Write, sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::FileAccess Access)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, Access,
                      sys::fs::OF_None) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::OpenFlags Flags)
     : raw_fd_ostream(Filename, EC, sys::fs::CD_CreateAlways, sys::fs::FA_Write,
                      Flags) {}
 
-raw_fd_ostream::raw_fd_ostream(StringRef Filename, std::error_code &EC,
+raw_fd_ostream::raw_fd_ostream(std::string_view Filename, std::error_code &EC,
                                sys::fs::CreationDisposition Disp,
                                sys::fs::FileAccess Access,
                                sys::fs::OpenFlags Flags)
@@ -679,8 +679,7 @@ raw_fd_ostream::~raw_fd_ostream() {
   // has_error() and clear the error flag with clear_error() before
   // destructing raw_ostream objects which may have errors.
   if (has_error())
-    report_fatal_error(Twine("IO failure on output stream: ") +
-                           error().message(),
+    report_fatal_error("IO failure on output stream: " + error().message(),
                        /*gen_crash_diag=*/false);
 }
 
@@ -699,7 +698,7 @@ raw_fd_ostream::~raw_fd_ostream() {
 // the input is UTF-8 or transcode from the local codepage to UTF-8 before
 // quoting it. If they don't, this may mess up the encoding, but this is still
 // probably the best compromise we can make.
-static bool write_console_impl(int FD, StringRef Data) {
+static bool write_console_impl(int FD, std::string_view Data) {
   SmallVector<wchar_t, 256> WideText;
 
   // Fall back to ::write if it wasn't valid UTF-8.
@@ -742,7 +741,7 @@ void raw_fd_ostream::write_impl(const char *Ptr, size_t Size) {
   // If this is a Windows console device, try re-encoding from UTF-8 to UTF-16
   // and using WriteConsoleW. If that fails, fall back to plain write().
   if (IsWindowsConsole)
-    if (write_console_impl(FD, StringRef(Ptr, Size)))
+    if (write_console_impl(FD, std::string_view(Ptr, Size)))
       return;
 #endif
 
@@ -906,7 +905,7 @@ raw_ostream &llvm::nulls() {
 // File Streams
 //===----------------------------------------------------------------------===//
 
-raw_fd_stream::raw_fd_stream(StringRef Filename, std::error_code &EC)
+raw_fd_stream::raw_fd_stream(std::string_view Filename, std::error_code &EC)
     : raw_fd_ostream(getFD(Filename, EC, sys::fs::CD_CreateAlways,
                            sys::fs::FA_Write | sys::fs::FA_Read,
                            sys::fs::OF_None),
@@ -984,7 +983,7 @@ void buffer_ostream::anchor() {}
 
 void buffer_unique_ostream::anchor() {}
 
-Error llvm::writeToOutput(StringRef OutputFileName,
+Error llvm::writeToOutput(std::string_view OutputFileName,
                           std::function<Error(raw_ostream &)> Write) {
   if (OutputFileName == "-")
     return Write(outs());
diff --git a/llvm/unittests/ADT/DenseMapTest.cpp b/llvm/unittests/ADT/DenseMapTest.cpp
index 4dd314c5c..e505b1907 100644
--- a/llvm/unittests/ADT/DenseMapTest.cpp
+++ b/llvm/unittests/ADT/DenseMapTest.cpp
@@ -481,31 +481,6 @@ TEST(DenseMapCustomTest, ReserveTest) {
   }
 }
 
-// Make sure DenseMap works with StringRef keys.
-TEST(DenseMapCustomTest, StringRefTest) {
-  DenseMap<StringRef, int> M;
-
-  M["a"] = 1;
-  M["b"] = 2;
-  M["c"] = 3;
-
-  EXPECT_EQ(3u, M.size());
-  EXPECT_EQ(1, M.lookup("a"));
-  EXPECT_EQ(2, M.lookup("b"));
-  EXPECT_EQ(3, M.lookup("c"));
-
-  EXPECT_EQ(0, M.lookup("q"));
-
-  // Test the empty string, spelled various ways.
-  EXPECT_EQ(0, M.lookup(""));
-  EXPECT_EQ(0, M.lookup(StringRef()));
-  EXPECT_EQ(0, M.lookup(StringRef("a", 0)));
-  M[""] = 42;
-  EXPECT_EQ(42, M.lookup(""));
-  EXPECT_EQ(42, M.lookup(StringRef()));
-  EXPECT_EQ(42, M.lookup(StringRef("a", 0)));
-}
-
 // Key traits that allows lookup with either an unsigned or char* key;
 // In the latter case, "a" == 0, "b" == 1 and so on.
 struct TestDenseMapInfo {
diff --git a/llvm/unittests/ADT/FunctionExtrasTest.cpp b/llvm/unittests/ADT/FunctionExtrasTest.cpp
index fc856a976..aff9d61c7 100644
--- a/llvm/unittests/ADT/FunctionExtrasTest.cpp
+++ b/llvm/unittests/ADT/FunctionExtrasTest.cpp
@@ -249,23 +249,23 @@ TEST(UniqueFunctionTest, Const) {
 
   // Overloaded call operator correctly resolved.
   struct ChooseCorrectOverload {
-    StringRef operator()() { return "non-const"; }
-    StringRef operator()() const { return "const"; }
+    std::string_view operator()() { return "non-const"; }
+    std::string_view operator()() const { return "const"; }
   };
-  unique_function<StringRef()> ChooseMutable = ChooseCorrectOverload();
+  unique_function<std::string_view()> ChooseMutable = ChooseCorrectOverload();
   ChooseCorrectOverload A;
   EXPECT_EQ("non-const", ChooseMutable());
   EXPECT_EQ("non-const", A());
-  unique_function<StringRef() const> ChooseConst = ChooseCorrectOverload();
+  unique_function<std::string_view() const> ChooseConst = ChooseCorrectOverload();
   const ChooseCorrectOverload &X = A;
   EXPECT_EQ("const", ChooseConst());
   EXPECT_EQ("const", X());
 }
 
 // Test that overloads on unique_functions are resolved as expected.
-std::string returns(StringRef) { return "not a function"; }
+std::string returns(std::string_view) { return "not a function"; }
 std::string returns(unique_function<double()> F) { return "number"; }
-std::string returns(unique_function<StringRef()> F) { return "string"; }
+std::string returns(unique_function<std::string_view()> F) { return "string"; }
 
 TEST(UniqueFunctionTest, SFINAE) {
   EXPECT_EQ("not a function", returns("boo!"));
diff --git a/llvm/unittests/ADT/HashingTest.cpp b/llvm/unittests/ADT/HashingTest.cpp
index bb19a5699..0634767a4 100644
--- a/llvm/unittests/ADT/HashingTest.cpp
+++ b/llvm/unittests/ADT/HashingTest.cpp
@@ -277,7 +277,7 @@ TEST(HashingTest, HashCombineRangeGoldenTest) {
 #endif
   };
   for (unsigned i = 0; i < sizeof(golden_data)/sizeof(*golden_data); ++i) {
-    StringRef str = golden_data[i].s;
+    std::string_view str = golden_data[i].s;
     hash_code hash = hash_combine_range(str.begin(), str.end());
 #if 0 // Enable this to generate paste-able text for the above structure.
     std::string member_str = "\"" + str.str() + "\",";
diff --git a/llvm/unittests/ADT/SmallPtrSetTest.cpp b/llvm/unittests/ADT/SmallPtrSetTest.cpp
index 414298c4e..6f3c94eed 100644
--- a/llvm/unittests/ADT/SmallPtrSetTest.cpp
+++ b/llvm/unittests/ADT/SmallPtrSetTest.cpp
@@ -12,7 +12,6 @@
 
 #include "llvm/ADT/SmallPtrSet.h"
 #include "llvm/ADT/PointerIntPair.h"
-#include "llvm/ADT/STLExtras.h"
 #include "llvm/Support/PointerLikeTypeTraits.h"
 #include "gtest/gtest.h"
 
diff --git a/llvm/unittests/ADT/SmallStringTest.cpp b/llvm/unittests/ADT/SmallStringTest.cpp
index b207f582e..bee3875d1 100644
--- a/llvm/unittests/ADT/SmallStringTest.cpp
+++ b/llvm/unittests/ADT/SmallStringTest.cpp
@@ -50,43 +50,43 @@ TEST_F(SmallStringTest, AssignRepeated) {
 }
 
 TEST_F(SmallStringTest, AssignIterPair) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AssignStringRef) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, AssignStringView) {
+  std::string_view abc = "abc";
   theString.assign(abc);
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
 TEST_F(SmallStringTest, AssignSmallVector) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   SmallVector<char, 10> abcVec(abc.begin(), abc.end());
   theString.assign(abcVec);
   EXPECT_EQ(3u, theString.size());
   EXPECT_STREQ("abc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AssignStringRefs) {
+TEST_F(SmallStringTest, AssignStringViews) {
   theString.assign({"abc", "def", "ghi"});
   EXPECT_EQ(9u, theString.size());
   EXPECT_STREQ("abcdefghi", theString.c_str());
 }
 
 TEST_F(SmallStringTest, AppendIterPair) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.append(abc.begin(), abc.end());
   theString.append(abc.begin(), abc.end());
   EXPECT_EQ(6u, theString.size());
   EXPECT_STREQ("abcabc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AppendStringRef) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, AppendStringView) {
+  std::string_view abc = "abc";
   theString.append(abc);
   theString.append(abc);
   EXPECT_EQ(6u, theString.size());
@@ -94,7 +94,7 @@ TEST_F(SmallStringTest, AppendStringRef) {
 }
 
 TEST_F(SmallStringTest, AppendSmallVector) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   SmallVector<char, 10> abcVec(abc.begin(), abc.end());
   theString.append(abcVec);
   theString.append(abcVec);
@@ -102,11 +102,11 @@ TEST_F(SmallStringTest, AppendSmallVector) {
   EXPECT_STREQ("abcabc", theString.c_str());
 }
 
-TEST_F(SmallStringTest, AppendStringRefs) {
+TEST_F(SmallStringTest, AppendStringViews) {
   theString.append({"abc", "def", "ghi"});
   EXPECT_EQ(9u, theString.size());
   EXPECT_STREQ("abcdefghi", theString.c_str());
-  StringRef Jkl = "jkl";
+  std::string_view Jkl = "jkl";
   std::string Mno = "mno";
   SmallString<4> Pqr("pqr");
   const char *Stu = "stu";
@@ -115,15 +115,15 @@ TEST_F(SmallStringTest, AppendStringRefs) {
   EXPECT_STREQ("abcdefghijklmnopqrstu", theString.c_str());
 }
 
-TEST_F(SmallStringTest, StringRefConversion) {
-  StringRef abc = "abc";
+TEST_F(SmallStringTest, StringViewConversion) {
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
-  StringRef theStringRef = theString;
-  EXPECT_EQ("abc", theStringRef);
+  std::string_view theStringView = theString;
+  EXPECT_EQ("abc", theStringView);
 }
 
 TEST_F(SmallStringTest, StdStringConversion) {
-  StringRef abc = "abc";
+  std::string_view abc = "abc";
   theString.assign(abc.begin(), abc.end());
   std::string theStdString = std::string(theString);
   EXPECT_EQ("abc", theStdString);
@@ -149,29 +149,29 @@ TEST_F(SmallStringTest, Slice) {
 TEST_F(SmallStringTest, Find) {
   theString = "hello";
   EXPECT_EQ(2U, theString.find('l'));
-  EXPECT_EQ(StringRef::npos, theString.find('z'));
-  EXPECT_EQ(StringRef::npos, theString.find("helloworld"));
+  EXPECT_EQ(std::string_view::npos, theString.find('z'));
+  EXPECT_EQ(std::string_view::npos, theString.find("helloworld"));
   EXPECT_EQ(0U, theString.find("hello"));
   EXPECT_EQ(1U, theString.find("ello"));
-  EXPECT_EQ(StringRef::npos, theString.find("zz"));
+  EXPECT_EQ(std::string_view::npos, theString.find("zz"));
   EXPECT_EQ(2U, theString.find("ll", 2));
-  EXPECT_EQ(StringRef::npos, theString.find("ll", 3));
+  EXPECT_EQ(std::string_view::npos, theString.find("ll", 3));
   EXPECT_EQ(0U, theString.find(""));
 
   EXPECT_EQ(3U, theString.rfind('l'));
-  EXPECT_EQ(StringRef::npos, theString.rfind('z'));
-  EXPECT_EQ(StringRef::npos, theString.rfind("helloworld"));
+  EXPECT_EQ(std::string_view::npos, theString.rfind('z'));
+  EXPECT_EQ(std::string_view::npos, theString.rfind("helloworld"));
   EXPECT_EQ(0U, theString.rfind("hello"));
   EXPECT_EQ(1U, theString.rfind("ello"));
-  EXPECT_EQ(StringRef::npos, theString.rfind("zz"));
+  EXPECT_EQ(std::string_view::npos, theString.rfind("zz"));
 
   EXPECT_EQ(2U, theString.find_first_of('l'));
   EXPECT_EQ(1U, theString.find_first_of("el"));
-  EXPECT_EQ(StringRef::npos, theString.find_first_of("xyz"));
+  EXPECT_EQ(std::string_view::npos, theString.find_first_of("xyz"));
 
   EXPECT_EQ(1U, theString.find_first_not_of('h'));
   EXPECT_EQ(4U, theString.find_first_not_of("hel"));
-  EXPECT_EQ(StringRef::npos, theString.find_first_not_of("hello"));
+  EXPECT_EQ(std::string_view::npos, theString.find_first_not_of("hello"));
 
   theString = "hellx xello hell ello world foo bar hello";
   EXPECT_EQ(36U, theString.find("hello"));
diff --git a/llvm/unittests/ADT/SmallVectorTest.cpp b/llvm/unittests/ADT/SmallVectorTest.cpp
index 3fbea5299..fe827546a 100644
--- a/llvm/unittests/ADT/SmallVectorTest.cpp
+++ b/llvm/unittests/ADT/SmallVectorTest.cpp
@@ -11,7 +11,7 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/SmallVector.h"
-#include "llvm/ADT/ArrayRef.h"
+#include "llvm/ADT/span.h"
 #include "llvm/Support/Compiler.h"
 #include "gtest/gtest.h"
 #include <list>
@@ -1070,24 +1070,6 @@ TEST(SmallVectorTest, DefaultInlinedElements) {
   EXPECT_EQ(NestedV[0][0][0], 42);
 }
 
-TEST(SmallVectorTest, InitializerList) {
-  SmallVector<int, 2> V1 = {};
-  EXPECT_TRUE(V1.empty());
-  V1 = {0, 0};
-  EXPECT_TRUE(makeArrayRef(V1).equals({0, 0}));
-  V1 = {-1, -1};
-  EXPECT_TRUE(makeArrayRef(V1).equals({-1, -1}));
-
-  SmallVector<int, 2> V2 = {1, 2, 3, 4};
-  EXPECT_TRUE(makeArrayRef(V2).equals({1, 2, 3, 4}));
-  V2.assign({4});
-  EXPECT_TRUE(makeArrayRef(V2).equals({4}));
-  V2.append({3, 2});
-  EXPECT_TRUE(makeArrayRef(V2).equals({4, 3, 2}));
-  V2.insert(V2.begin() + 1, 5);
-  EXPECT_TRUE(makeArrayRef(V2).equals({4, 5, 3, 2}));
-}
-
 template <class VectorT>
 class SmallVectorReferenceInvalidationTest : public SmallVectorTestBase {
 protected:
diff --git a/llvm/unittests/ADT/StringMapTest.cpp b/llvm/unittests/ADT/StringMapTest.cpp
index 817fec6c3..86907ab61 100644
--- a/llvm/unittests/ADT/StringMapTest.cpp
+++ b/llvm/unittests/ADT/StringMapTest.cpp
@@ -7,8 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/ADT/StringMap.h"
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/ADT/Twine.h"
 #include "llvm/Support/DataTypes.h"
 #include "gtest/gtest.h"
 #include <limits>
@@ -38,10 +36,10 @@ protected:
 
     // Lookup tests
     EXPECT_EQ(0u, testMap.count(testKey));
-    EXPECT_EQ(0u, testMap.count(StringRef(testKeyFirst, testKeyLength)));
+    EXPECT_EQ(0u, testMap.count(std::string_view(testKeyFirst, testKeyLength)));
     EXPECT_EQ(0u, testMap.count(testKeyStr));
     EXPECT_TRUE(testMap.find(testKey) == testMap.end());
-    EXPECT_TRUE(testMap.find(StringRef(testKeyFirst, testKeyLength)) == 
+    EXPECT_TRUE(testMap.find(std::string_view(testKeyFirst, testKeyLength)) == 
                 testMap.end());
     EXPECT_TRUE(testMap.find(testKeyStr) == testMap.end());
   }
@@ -61,10 +59,10 @@ protected:
 
     // Lookup tests
     EXPECT_EQ(1u, testMap.count(testKey));
-    EXPECT_EQ(1u, testMap.count(StringRef(testKeyFirst, testKeyLength)));
+    EXPECT_EQ(1u, testMap.count(std::string_view(testKeyFirst, testKeyLength)));
     EXPECT_EQ(1u, testMap.count(testKeyStr));
     EXPECT_TRUE(testMap.find(testKey) == testMap.begin());
-    EXPECT_TRUE(testMap.find(StringRef(testKeyFirst, testKeyLength)) == 
+    EXPECT_TRUE(testMap.find(std::string_view(testKeyFirst, testKeyLength)) == 
                 testMap.begin());
     EXPECT_TRUE(testMap.find(testKeyStr) == testMap.begin());
   }
@@ -104,10 +102,10 @@ TEST_F(StringMapTest, ConstEmptyMapTest) {
 
   // Lookup tests
   EXPECT_EQ(0u, constTestMap.count(testKey));
-  EXPECT_EQ(0u, constTestMap.count(StringRef(testKeyFirst, testKeyLength)));
+  EXPECT_EQ(0u, constTestMap.count(std::string_view(testKeyFirst, testKeyLength)));
   EXPECT_EQ(0u, constTestMap.count(testKeyStr));
   EXPECT_TRUE(constTestMap.find(testKey) == constTestMap.end());
-  EXPECT_TRUE(constTestMap.find(StringRef(testKeyFirst, testKeyLength)) ==
+  EXPECT_TRUE(constTestMap.find(std::string_view(testKeyFirst, testKeyLength)) ==
               constTestMap.end());
   EXPECT_TRUE(constTestMap.find(testKeyStr) == constTestMap.end());
 }
@@ -235,7 +233,7 @@ TEST_F(StringMapTest, StringMapEntryTest) {
   MallocAllocator Allocator;
   StringMap<uint32_t>::value_type *entry =
       StringMap<uint32_t>::value_type::Create(
-          StringRef(testKeyFirst, testKeyLength), Allocator, 1u);
+          std::string_view(testKeyFirst, testKeyLength), Allocator, 1u);
   EXPECT_STREQ(testKey, entry->first().data());
   EXPECT_EQ(1u, entry->second);
   entry->Destroy(Allocator);
@@ -246,7 +244,7 @@ TEST_F(StringMapTest, InsertTest) {
   SCOPED_TRACE("InsertTest");
   testMap.insert(
       StringMap<uint32_t>::value_type::Create(
-          StringRef(testKeyFirst, testKeyLength),
+          std::string_view(testKeyFirst, testKeyLength),
           testMap.getAllocator(), 1u));
   assertSingleItemMap();
 }
@@ -316,10 +314,10 @@ TEST_F(StringMapTest, IterMapKeysVector) {
   Map["C"] = 3;
   Map["D"] = 3;
 
-  std::vector<StringRef> Keys{Map.keys().begin(), Map.keys().end()};
+  std::vector<std::string_view> Keys{Map.keys().begin(), Map.keys().end()};
   llvm::sort(Keys);
 
-  std::vector<StringRef> Expected{{"A", "B", "C", "D"}};
+  std::vector<std::string_view> Expected{{"A", "B", "C", "D"}};
   EXPECT_EQ(Expected, Keys);
 }
 
@@ -333,7 +331,7 @@ TEST_F(StringMapTest, IterMapKeysSmallVector) {
   auto Keys = to_vector<4>(Map.keys());
   llvm::sort(Keys);
 
-  SmallVector<StringRef, 4> Expected = {"A", "B", "C", "D"};
+  SmallVector<std::string_view, 4> Expected = {"A", "B", "C", "D"};
   EXPECT_EQ(Expected, Keys);
 }
 
@@ -375,13 +373,13 @@ private:
 TEST_F(StringMapTest, MoveOnly) {
   StringMap<MoveOnly> t;
   t.insert(std::make_pair("Test", MoveOnly(42)));
-  StringRef Key = "Test";
+  std::string_view Key = "Test";
   StringMapEntry<MoveOnly>::Create(Key, t.getAllocator(), MoveOnly(42))
       ->Destroy(t.getAllocator());
 }
 
 TEST_F(StringMapTest, CtorArg) {
-  StringRef Key = "Test";
+  std::string_view Key = "Test";
   MallocAllocator Allocator;
   StringMapEntry<MoveOnly>::Create(Key, Allocator, Immovable())
       ->Destroy(Allocator);
@@ -556,7 +554,7 @@ TEST(StringMapCustomTest, InitialSizeTest) {
     CountCtorCopyAndMove::Copy = 0;
     for (int i = 0; i < Size; ++i)
       Map.insert(std::pair<std::string, CountCtorCopyAndMove>(
-          std::piecewise_construct, std::forward_as_tuple(Twine(i).str()),
+          std::piecewise_construct, std::forward_as_tuple(std::to_string(i)),
           std::forward_as_tuple(i)));
     // After the initial move, the map will move the Elts in the Entry.
     EXPECT_EQ((unsigned)Size * 2, CountCtorCopyAndMove::Move);
@@ -625,7 +623,7 @@ TEST(StringMapCustomTest, StringMapEntrySize) {
   else
     LargeValue = std::numeric_limits<unsigned>::max() + 1ULL;
   StringMapEntry<int> LargeEntry(LargeValue);
-  StringRef Key = LargeEntry.getKey();
+  std::string_view Key = LargeEntry.getKey();
   EXPECT_EQ(LargeValue, Key.size());
 
   // Test that the entry can hold at least max size_t.
diff --git a/llvm/unittests/Support/ConvertUTFTest.cpp b/llvm/unittests/Support/ConvertUTFTest.cpp
index 7bda6ea28..9c798437a 100644
--- a/llvm/unittests/Support/ConvertUTFTest.cpp
+++ b/llvm/unittests/Support/ConvertUTFTest.cpp
@@ -7,7 +7,6 @@
 //===----------------------------------------------------------------------===//
 
 #include "llvm/Support/ConvertUTF.h"
-#include "llvm/ADT/ArrayRef.h"
 #include "gtest/gtest.h"
 #include <string>
 #include <vector>
@@ -17,7 +16,7 @@ using namespace llvm;
 TEST(ConvertUTFTest, ConvertUTF16LittleEndianToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF16) static const char Src[] = "\xff\xfe\xa0\x0c_\x00\xa0\x0c";
-  ArrayRef<char> Ref(Src, sizeof(Src) - 1);
+  span<const char> Ref(Src, sizeof(Src) - 1);
   std::string Result;
   bool Success = convertUTF16ToUTF8String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -28,7 +27,7 @@ TEST(ConvertUTFTest, ConvertUTF16LittleEndianToUTF8String) {
 TEST(ConvertUTFTest, ConvertUTF16BigEndianToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF16) static const char Src[] = "\xfe\xff\x0c\xa0\x00_\x0c\xa0";
-  ArrayRef<char> Ref(Src, sizeof(Src) - 1);
+  span<const char> Ref(Src, sizeof(Src) - 1);
   std::string Result;
   bool Success = convertUTF16ToUTF8String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -39,7 +38,7 @@ TEST(ConvertUTFTest, ConvertUTF16BigEndianToUTF8String) {
 TEST(ConvertUTFTest, ConvertUTF8ToUTF16String) {
   // Src is the look of disapproval.
   static const char Src[] = "\xe0\xb2\xa0_\xe0\xb2\xa0";
-  StringRef Ref(Src, sizeof(Src) - 1);
+  std::string_view Ref(Src, sizeof(Src) - 1);
   SmallVector<UTF16, 5> Result;
   bool Success = convertUTF8ToUTF16String(Ref, Result);
   EXPECT_TRUE(Success);
@@ -51,37 +50,37 @@ TEST(ConvertUTFTest, ConvertUTF8ToUTF16String) {
 
 TEST(ConvertUTFTest, OddLengthInput) {
   std::string Result;
-  bool Success = convertUTF16ToUTF8String(makeArrayRef("xxxxx", 5), Result);
+  bool Success = convertUTF16ToUTF8String(span<const char>("xxxxx", 5), Result);
   EXPECT_FALSE(Success);
 }
 
 TEST(ConvertUTFTest, Empty) {
   std::string Result;
-  bool Success = convertUTF16ToUTF8String(llvm::ArrayRef<char>(None), Result);
+  bool Success = convertUTF16ToUTF8String(span<const char>(), Result);
   EXPECT_TRUE(Success);
   EXPECT_TRUE(Result.empty());
 }
 
 TEST(ConvertUTFTest, HasUTF16BOM) {
-  bool HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xff\xfe", 2));
+  bool HasBOM = hasUTF16ByteOrderMark("\xff\xfe");
   EXPECT_TRUE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe\xff", 2));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff");
   EXPECT_TRUE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe\xff ", 3));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff ");
   EXPECT_TRUE(HasBOM); // Don't care about odd lengths.
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe\xff\x00asdf", 6));
+  HasBOM = hasUTF16ByteOrderMark("\xfe\xff\x00asdf");
   EXPECT_TRUE(HasBOM);
 
-  HasBOM = hasUTF16ByteOrderMark(None);
+  HasBOM = hasUTF16ByteOrderMark("");
   EXPECT_FALSE(HasBOM);
-  HasBOM = hasUTF16ByteOrderMark(makeArrayRef("\xfe", 1));
+  HasBOM = hasUTF16ByteOrderMark("\xfe");
   EXPECT_FALSE(HasBOM);
 }
 
 TEST(ConvertUTFTest, UTF16WrappersForConvertUTF16ToUTF8String) {
   // Src is the look of disapproval.
   alignas(UTF16) static const char Src[] = "\xff\xfe\xa0\x0c_\x00\xa0\x0c";
-  ArrayRef<UTF16> SrcRef = makeArrayRef((const UTF16 *)Src, 4);
+  span<const UTF16> SrcRef((const UTF16 *)Src, 4);
   std::string Result;
   bool Success = convertUTF16ToUTF8String(SrcRef, Result);
   EXPECT_TRUE(Success);
@@ -98,7 +97,7 @@ TEST(ConvertUTFTest, ConvertUTF8toWide) {
   std::wstring Expected(L"\x0ca0_\x0ca0");
   EXPECT_EQ(Expected, Result);
   Result.clear();
-  Success = ConvertUTF8toWide(StringRef(Src, 7), Result);
+  Success = ConvertUTF8toWide(Src, Result);
   EXPECT_TRUE(Success);
   EXPECT_EQ(Expected, Result);
 }
@@ -147,7 +146,7 @@ struct ConvertUTFResultContainer {
 };
 
 std::pair<ConversionResult, std::vector<unsigned>>
-ConvertUTF8ToUnicodeScalarsLenient(StringRef S) {
+ConvertUTF8ToUnicodeScalarsLenient(std::string_view S) {
   const UTF8 *SourceStart = reinterpret_cast<const UTF8 *>(S.data());
 
   const UTF8 *SourceNext = SourceStart;
@@ -164,7 +163,7 @@ ConvertUTF8ToUnicodeScalarsLenient(StringRef S) {
 }
 
 std::pair<ConversionResult, std::vector<unsigned>>
-ConvertUTF8ToUnicodeScalarsPartialLenient(StringRef S) {
+ConvertUTF8ToUnicodeScalarsPartialLenient(std::string_view S) {
   const UTF8 *SourceStart = reinterpret_cast<const UTF8 *>(S.data());
 
   const UTF8 *SourceNext = SourceStart;
@@ -182,7 +181,7 @@ ConvertUTF8ToUnicodeScalarsPartialLenient(StringRef S) {
 
 ::testing::AssertionResult
 CheckConvertUTF8ToUnicodeScalars(ConvertUTFResultContainer Expected,
-                                 StringRef S, bool Partial = false) {
+                                 std::string_view S, bool Partial = false) {
   ConversionResult ErrorCode;
   std::vector<unsigned> Decoded;
   if (!Partial)
@@ -277,7 +276,7 @@ TEST(ConvertUTFTest, UTF8ToUTF32Lenient) {
   // U+0000 NULL
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
       ConvertUTFResultContainer(conversionOK).withScalars(0x0000),
-      StringRef("\x00", 1)));
+      std::string_view("\x00", 1)));
 
   // U+0080 PADDING CHARACTER
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
@@ -1051,7 +1050,7 @@ TEST(ConvertUTFTest, UTF8ToUTF32Lenient) {
   // U+0000 NULL
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
       ConvertUTFResultContainer(conversionOK).withScalars(0x0000),
-      StringRef("\x00", 1)));
+      std::string_view("\x00", 1)));
 
   // Overlong sequences of the above.
   EXPECT_TRUE(CheckConvertUTF8ToUnicodeScalars(
