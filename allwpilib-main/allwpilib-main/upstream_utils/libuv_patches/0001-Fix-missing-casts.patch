From d5613423f057b088f6b3753f49162947d5559ad9 Mon Sep 17 00:00:00 2001
From: PJ Reiniger <pj.reiniger@gmail.com>
Date: Tue, 26 Apr 2022 15:01:25 -0400
Subject: [PATCH 1/9] Fix missing casts

---
 include/uv/unix.h              |  2 +-
 src/fs-poll.c                  | 10 ++++-----
 src/inet.c                     | 11 +++++-----
 src/strscpy.c                  |  2 +-
 src/threadpool.c               |  2 +-
 src/unix/bsd-ifaddrs.c         |  2 +-
 src/unix/core.c                | 12 +++++-----
 src/unix/darwin-proctitle.c    |  5 +++--
 src/unix/darwin.c              |  2 +-
 src/unix/epoll.c               |  2 +-
 src/unix/freebsd.c             |  4 ++--
 src/unix/fs.c                  | 20 ++++++++---------
 src/unix/fsevents.c            | 40 +++++++++++++++++-----------------
 src/unix/getaddrinfo.c         |  8 +++----
 src/unix/ibmi.c                |  2 +-
 src/unix/kqueue.c              |  6 ++---
 src/unix/linux-core.c          |  5 ++---
 src/unix/linux-inotify.c       |  4 ++--
 src/unix/loop.c                |  2 +-
 src/unix/netbsd.c              |  4 ++--
 src/unix/openbsd.c             |  4 ++--
 src/unix/pipe.c                |  4 ++--
 src/unix/poll.c                |  2 +-
 src/unix/posix-poll.c          |  2 +-
 src/unix/process.c             |  4 ++--
 src/unix/proctitle.c           |  2 +-
 src/unix/random-sysctl-linux.c |  2 +-
 src/unix/stream.c              | 35 ++++++++++++++---------------
 src/unix/thread.c              |  7 +++---
 src/unix/udp.c                 |  8 +++----
 src/uv-common.c                | 16 +++++++-------
 src/win/core.c                 |  8 ++++---
 src/win/fs-event.c             |  4 ++--
 src/win/fs-fd-hash-inl.h       |  2 +-
 src/win/fs.c                   | 26 +++++++++++-----------
 src/win/pipe.c                 | 10 ++++-----
 src/win/process.c              | 12 +++++-----
 src/win/tcp.c                  |  2 +-
 src/win/thread.c               |  4 ++--
 src/win/util.c                 | 29 ++++++++++++------------
 40 files changed, 166 insertions(+), 162 deletions(-)

diff --git a/include/uv/unix.h b/include/uv/unix.h
index ea37d787..420be86c 100644
--- a/include/uv/unix.h
+++ b/include/uv/unix.h
@@ -223,7 +223,7 @@ typedef struct {
   int backend_fd;                                                             \
   void* pending_queue[2];                                                     \
   void* watcher_queue[2];                                                     \
-  uv__io_t** watchers;                                                        \
+  void** watchers;                                                            \
   unsigned int nwatchers;                                                     \
   unsigned int nfds;                                                          \
   void* wq[2];                                                                \
diff --git a/src/fs-poll.c b/src/fs-poll.c
index 1bac1c56..5a39daed 100644
--- a/src/fs-poll.c
+++ b/src/fs-poll.c
@@ -77,7 +77,7 @@ int uv_fs_poll_start(uv_fs_poll_t* handle,
 
   loop = handle->loop;
   len = strlen(path);
-  ctx = uv__calloc(1, sizeof(*ctx) + len);
+  ctx = (struct poll_ctx*)uv__calloc(1, sizeof(*ctx) + len);
 
   if (ctx == NULL)
     return UV_ENOMEM;
@@ -101,7 +101,7 @@ int uv_fs_poll_start(uv_fs_poll_t* handle,
     goto error;
 
   if (handle->poll_ctx != NULL)
-    ctx->previous = handle->poll_ctx;
+    ctx->previous = (struct poll_ctx*)handle->poll_ctx;
   handle->poll_ctx = ctx;
   uv__handle_start(handle);
 
@@ -119,7 +119,7 @@ int uv_fs_poll_stop(uv_fs_poll_t* handle) {
   if (!uv_is_active((uv_handle_t*)handle))
     return 0;
 
-  ctx = handle->poll_ctx;
+  ctx = (struct poll_ctx*)handle->poll_ctx;
   assert(ctx != NULL);
   assert(ctx->parent_handle == handle);
 
@@ -144,7 +144,7 @@ int uv_fs_poll_getpath(uv_fs_poll_t* handle, char* buffer, size_t* size) {
     return UV_EINVAL;
   }
 
-  ctx = handle->poll_ctx;
+  ctx = (struct poll_ctx*)handle->poll_ctx;
   assert(ctx != NULL);
 
   required_len = strlen(ctx->path);
@@ -244,7 +244,7 @@ static void timer_close_cb(uv_handle_t* timer) {
     if (handle->poll_ctx == NULL && uv__is_closing(handle))
       uv__make_close_pending((uv_handle_t*)handle);
   } else {
-    for (last = handle->poll_ctx, it = last->previous;
+    for (last = (struct poll_ctx*)handle->poll_ctx, it = last->previous;
          it != ctx;
          last = it, it = it->previous) {
       assert(last->previous != NULL);
diff --git a/src/inet.c b/src/inet.c
index ddabf22f..ca8b6ac8 100644
--- a/src/inet.c
+++ b/src/inet.c
@@ -40,9 +40,9 @@ static int inet_pton6(const char *src, unsigned char *dst);
 int uv_inet_ntop(int af, const void* src, char* dst, size_t size) {
   switch (af) {
   case AF_INET:
-    return (inet_ntop4(src, dst, size));
+    return (inet_ntop4((const unsigned char*)src, dst, size));
   case AF_INET6:
-    return (inet_ntop6(src, dst, size));
+    return (inet_ntop6((const unsigned char*)src, dst, size));
   default:
     return UV_EAFNOSUPPORT;
   }
@@ -154,10 +154,11 @@ int uv_inet_pton(int af, const char* src, void* dst) {
 
   switch (af) {
   case AF_INET:
-    return (inet_pton4(src, dst));
+    return (inet_pton4(src, (unsigned char*)dst));
   case AF_INET6: {
     int len;
-    char tmp[UV__INET6_ADDRSTRLEN], *s, *p;
+    char tmp[UV__INET6_ADDRSTRLEN], *s;
+    const char *p;
     s = (char*) src;
     p = strchr(src, '%');
     if (p != NULL) {
@@ -168,7 +169,7 @@ int uv_inet_pton(int af, const char* src, void* dst) {
       memcpy(s, src, len);
       s[len] = '\0';
     }
-    return inet_pton6(s, dst);
+    return inet_pton6(s, (unsigned char*)dst);
   }
   default:
     return UV_EAFNOSUPPORT;
diff --git a/src/strscpy.c b/src/strscpy.c
index 20df6fcb..6b4cc3bc 100644
--- a/src/strscpy.c
+++ b/src/strscpy.c
@@ -27,7 +27,7 @@ ssize_t uv__strscpy(char* d, const char* s, size_t n) {
 
   for (i = 0; i < n; i++)
     if ('\0' == (d[i] = s[i]))
-      return i > SSIZE_MAX ? UV_E2BIG : (ssize_t) i;
+      return i > SSIZE_MAX ? (ssize_t) UV_E2BIG : (ssize_t) i;
 
   if (i == 0)
     return 0;
diff --git a/src/threadpool.c b/src/threadpool.c
index e804c7c4..1241ace1 100644
--- a/src/threadpool.c
+++ b/src/threadpool.c
@@ -206,7 +206,7 @@ static void init_threads(void) {
 
   threads = default_threads;
   if (nthreads > ARRAY_SIZE(default_threads)) {
-    threads = uv__malloc(nthreads * sizeof(threads[0]));
+    threads = (uv_thread_t*)uv__malloc(nthreads * sizeof(threads[0]));
     if (threads == NULL) {
       nthreads = ARRAY_SIZE(default_threads);
       threads = default_threads;
diff --git a/src/unix/bsd-ifaddrs.c b/src/unix/bsd-ifaddrs.c
index 11ca9559..c3dd71a1 100644
--- a/src/unix/bsd-ifaddrs.c
+++ b/src/unix/bsd-ifaddrs.c
@@ -92,7 +92,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
   }
 
   /* Make sure the memory is initiallized to zero using calloc() */
-  *addresses = uv__calloc(*count, sizeof(**addresses));
+  *addresses = (uv_interface_address_t*)uv__calloc(*count, sizeof(**addresses));
 
   if (*addresses == NULL) {
     freeifaddrs(addrs);
diff --git a/src/unix/core.c b/src/unix/core.c
index 54c769f3..6353b0e3 100644
--- a/src/unix/core.c
+++ b/src/unix/core.c
@@ -824,7 +824,7 @@ static unsigned int next_power_of_two(unsigned int val) {
 }
 
 static void maybe_resize(uv_loop_t* loop, unsigned int len) {
-  uv__io_t** watchers;
+  void** watchers;
   void* fake_watcher_list;
   void* fake_watcher_count;
   unsigned int nwatchers;
@@ -843,8 +843,8 @@ static void maybe_resize(uv_loop_t* loop, unsigned int len) {
   }
 
   nwatchers = next_power_of_two(len + 2) - 2;
-  watchers = uv__reallocf(loop->watchers,
-                          (nwatchers + 2) * sizeof(loop->watchers[0]));
+  watchers = (void**)
+      uv__reallocf(loop->watchers, (nwatchers + 2) * sizeof(loop->watchers[0]));
 
   if (watchers == NULL)
     abort();
@@ -1184,7 +1184,7 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
    * is frequently 1024 or 4096, so we can just use that directly. The pwent
    * will not usually be large. */
   for (bufsize = 2000;; bufsize *= 2) {
-    buf = uv__malloc(bufsize);
+    buf = (char*)uv__malloc(bufsize);
 
     if (buf == NULL)
       return UV_ENOMEM;
@@ -1210,7 +1210,7 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
   name_size = strlen(pw.pw_name) + 1;
   homedir_size = strlen(pw.pw_dir) + 1;
   shell_size = strlen(pw.pw_shell) + 1;
-  pwd->username = uv__malloc(name_size + homedir_size + shell_size);
+  pwd->username = (char*)uv__malloc(name_size + homedir_size + shell_size);
 
   if (pwd->username == NULL) {
     uv__free(buf);
@@ -1274,7 +1274,7 @@ int uv_os_environ(uv_env_item_t** envitems, int* count) {
 
   for (i = 0; environ[i] != NULL; i++);
 
-  *envitems = uv__calloc(i, sizeof(**envitems));
+  *envitems = (uv_env_item_s*)uv__calloc(i, sizeof(**envitems));
 
   if (*envitems == NULL)
     return UV_ENOMEM;
diff --git a/src/unix/darwin-proctitle.c b/src/unix/darwin-proctitle.c
index 5288083e..9bd55dd7 100644
--- a/src/unix/darwin-proctitle.c
+++ b/src/unix/darwin-proctitle.c
@@ -128,8 +128,9 @@ int uv__set_process_title(const char* title) {
   if (pLSSetApplicationInformationItem == NULL)
     goto out;
 
-  display_name_key = pCFBundleGetDataPointerForName(launch_services_bundle,
-                                                    S("_kLSDisplayNameKey"));
+  display_name_key = (CFStringRef*)
+      pCFBundleGetDataPointerForName(launch_services_bundle,
+                                     S("_kLSDisplayNameKey"));
 
   if (display_name_key == NULL || *display_name_key == NULL)
     goto out;
diff --git a/src/unix/darwin.c b/src/unix/darwin.c
index 62f04d31..5fbf7342 100644
--- a/src/unix/darwin.c
+++ b/src/unix/darwin.c
@@ -353,7 +353,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
     return UV_EINVAL;  /* FIXME(bnoordhuis) Translate error. */
   }
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos)) {
     vm_deallocate(mach_task_self(), (vm_address_t)info, msg_type);
     return UV_ENOMEM;
diff --git a/src/unix/epoll.c b/src/unix/epoll.c
index 97348e25..4c057fb3 100644
--- a/src/unix/epoll.c
+++ b/src/unix/epoll.c
@@ -325,7 +325,7 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
       assert(fd >= 0);
       assert((unsigned) fd < loop->nwatchers);
 
-      w = loop->watchers[fd];
+      w = (uv__io_t*)loop->watchers[fd];
 
       if (w == NULL) {
         /* File descriptor that we've stopped watching, disarm it.
diff --git a/src/unix/freebsd.c b/src/unix/freebsd.c
index 658ff262..6700ff61 100644
--- a/src/unix/freebsd.c
+++ b/src/unix/freebsd.c
@@ -215,7 +215,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
   if (sysctlbyname("hw.ncpu", &numcpus, &size, NULL, 0))
     return UV__ERR(errno);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos))
     return UV_ENOMEM;
 
@@ -232,7 +232,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
 
   size = maxcpus * CPUSTATES * sizeof(long);
 
-  cp_times = uv__malloc(size);
+  cp_times = (long*)uv__malloc(size);
   if (cp_times == NULL) {
     uv__free(*cpu_infos);
     return UV_ENOMEM;
diff --git a/src/unix/fs.c b/src/unix/fs.c
index 933c9c0d..1a615244 100644
--- a/src/unix/fs.c
+++ b/src/unix/fs.c
@@ -137,7 +137,7 @@ extern char *mkdtemp(char *template); /* See issue #740 on AIX < 7 */
       size_t new_path_len;                                                    \
       path_len = strlen(path) + 1;                                            \
       new_path_len = strlen(new_path) + 1;                                    \
-      req->path = uv__malloc(path_len + new_path_len);                        \
+      req->path = (char*)uv__malloc(path_len + new_path_len);                 \
       if (req->path == NULL)                                                  \
         return UV_ENOMEM;                                                     \
       req->new_path = req->path + path_len;                                   \
@@ -572,7 +572,7 @@ static ssize_t uv__fs_scandir(uv_fs_t* req) {
 static int uv__fs_opendir(uv_fs_t* req) {
   uv_dir_t* dir;
 
-  dir = uv__malloc(sizeof(*dir));
+  dir = (uv_dir_t*)uv__malloc(sizeof(*dir));
   if (dir == NULL)
     goto error;
 
@@ -596,7 +596,7 @@ static int uv__fs_readdir(uv_fs_t* req) {
   unsigned int dirent_idx;
   unsigned int i;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   dirent_idx = 0;
 
   while (dirent_idx < dir->nentries) {
@@ -638,7 +638,7 @@ error:
 static int uv__fs_closedir(uv_fs_t* req) {
   uv_dir_t* dir;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
 
   if (dir->dir != NULL) {
     closedir(dir->dir);
@@ -667,7 +667,7 @@ static int uv__fs_statfs(uv_fs_t* req) {
 #endif /* defined(__sun) */
     return -1;
 
-  stat_fs = uv__malloc(sizeof(*stat_fs));
+  stat_fs = (uv_statfs_t*)uv__malloc(sizeof(*stat_fs));
   if (stat_fs == NULL) {
     errno = ENOMEM;
     return -1;
@@ -731,7 +731,7 @@ static ssize_t uv__fs_readlink(uv_fs_t* req) {
     maxlen = uv__fs_pathmax_size(req->path);
 #endif
 
-  buf = uv__malloc(maxlen);
+  buf = (char*)uv__malloc(maxlen);
 
   if (buf == NULL) {
     errno = ENOMEM;
@@ -751,7 +751,7 @@ static ssize_t uv__fs_readlink(uv_fs_t* req) {
 
   /* Uncommon case: resize to make room for the trailing nul byte. */
   if (len == maxlen) {
-    buf = uv__reallocf(buf, len + 1);
+    buf = (char*)uv__reallocf(buf, len + 1);
 
     if (buf == NULL)
       return -1;
@@ -774,7 +774,7 @@ static ssize_t uv__fs_realpath(uv_fs_t* req) {
   ssize_t len;
 
   len = uv__fs_pathmax_size(req->path);
-  buf = uv__malloc(len + 1);
+  buf = (char*)uv__malloc(len + 1);
 
   if (buf == NULL) {
     errno = ENOMEM;
@@ -2010,7 +2010,7 @@ int uv_fs_read(uv_loop_t* loop, uv_fs_t* req,
   req->nbufs = nbufs;
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->bufs == NULL)
     return UV_ENOMEM;
@@ -2180,7 +2180,7 @@ int uv_fs_write(uv_loop_t* loop,
   req->nbufs = nbufs;
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->bufs == NULL)
     return UV_ENOMEM;
diff --git a/src/unix/fsevents.c b/src/unix/fsevents.c
index bf4f1f6a..648c8a98 100644
--- a/src/unix/fsevents.c
+++ b/src/unix/fsevents.c
@@ -185,7 +185,7 @@ static void (*pFSEventStreamStop)(FSEventStreamRef);
 static void uv__fsevents_cb(uv_async_t* cb) {
   uv_fs_event_t* handle;
 
-  handle = cb->data;
+  handle = (uv_fs_event_t*)cb->data;
 
   UV__FSEVENTS_PROCESS(handle, {
     handle->cb(handle, event->path[0] ? event->path : NULL, event->events, 0);
@@ -233,10 +233,10 @@ static void uv__fsevents_event_cb(const FSEventStreamRef streamRef,
   FSEventStreamEventFlags flags;
   QUEUE head;
 
-  loop = info;
-  state = loop->cf_state;
+  loop = (uv_loop_t*)info;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   assert(state != NULL);
-  paths = eventPaths;
+  paths = (char**)eventPaths;
 
   /* For each handle */
   uv_mutex_lock(&state->fsevent_mutex);
@@ -306,7 +306,7 @@ static void uv__fsevents_event_cb(const FSEventStreamRef streamRef,
           continue;
       }
 
-      event = uv__malloc(sizeof(*event) + len);
+      event = (uv__fsevents_event_t*)uv__malloc(sizeof(*event) + len);
       if (event == NULL)
         break;
 
@@ -373,7 +373,7 @@ static int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {
                              flags);
   assert(ref != NULL);
 
-  state = loop->cf_state;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   pFSEventStreamScheduleWithRunLoop(ref,
                                     state->loop,
                                     *pkCFRunLoopDefaultMode);
@@ -392,7 +392,7 @@ static int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {
 static void uv__fsevents_destroy_stream(uv_loop_t* loop) {
   uv__cf_loop_state_t* state;
 
-  state = loop->cf_state;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
 
   if (state->fsevent_stream == NULL)
     return;
@@ -419,7 +419,7 @@ static void uv__fsevents_reschedule(uv_fs_event_t* handle,
   int err;
   unsigned int path_count;
 
-  state = handle->loop->cf_state;
+  state = (uv__cf_loop_state_t*)handle->loop->cf_state;
   paths = NULL;
   cf_paths = NULL;
   err = 0;
@@ -447,7 +447,7 @@ static void uv__fsevents_reschedule(uv_fs_event_t* handle,
   uv_mutex_lock(&state->fsevent_mutex);
   path_count = state->fsevent_handle_count;
   if (path_count != 0) {
-    paths = uv__malloc(sizeof(*paths) * path_count);
+    paths = (CFStringRef*)uv__malloc(sizeof(*paths) * path_count);
     if (paths == NULL) {
       uv_mutex_unlock(&state->fsevent_mutex);
       goto final;
@@ -605,7 +605,7 @@ static int uv__fsevents_loop_init(uv_loop_t* loop) {
   if (err)
     return err;
 
-  state = uv__calloc(1, sizeof(*state));
+  state = (uv__cf_loop_state_t*)uv__calloc(1, sizeof(*state));
   if (state == NULL)
     return UV_ENOMEM;
 
@@ -707,7 +707,7 @@ void uv__fsevents_loop_delete(uv_loop_t* loop) {
   }
 
   /* Destroy state */
-  state = loop->cf_state;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   uv_sem_destroy(&state->fsevent_sem);
   uv_mutex_destroy(&state->fsevent_mutex);
   pCFRelease(state->signal_source);
@@ -721,8 +721,8 @@ static void* uv__cf_loop_runner(void* arg) {
   uv_loop_t* loop;
   uv__cf_loop_state_t* state;
 
-  loop = arg;
-  state = loop->cf_state;
+  loop = (uv_loop_t*)arg;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   state->loop = pCFRunLoopGetCurrent();
 
   pCFRunLoopAddSource(state->loop,
@@ -750,8 +750,8 @@ static void uv__cf_loop_cb(void* arg) {
   QUEUE split_head;
   uv__cf_loop_signal_t* s;
 
-  loop = arg;
-  state = loop->cf_state;
+  loop = (uv_loop_t*)arg;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
 
   uv_mutex_lock(&loop->cf_mutex);
   QUEUE_MOVE(&loop->cf_signals, &split_head);
@@ -781,7 +781,7 @@ int uv__cf_loop_signal(uv_loop_t* loop,
   uv__cf_loop_signal_t* item;
   uv__cf_loop_state_t* state;
 
-  item = uv__malloc(sizeof(*item));
+  item = (uv__cf_loop_signal_t*)uv__malloc(sizeof(*item));
   if (item == NULL)
     return UV_ENOMEM;
 
@@ -791,7 +791,7 @@ int uv__cf_loop_signal(uv_loop_t* loop,
   uv_mutex_lock(&loop->cf_mutex);
   QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);
 
-  state = loop->cf_state;
+  state = (uv__cf_loop_state_t*)loop->cf_state;
   assert(state != NULL);
   pCFRunLoopSourceSignal(state->signal_source);
   pCFRunLoopWakeUp(state->loop);
@@ -825,7 +825,7 @@ int uv__fsevents_init(uv_fs_event_t* handle) {
    * Events will occur in other thread.
    * Initialize callback for getting them back into event loop's thread
    */
-  handle->cf_cb = uv__malloc(sizeof(*handle->cf_cb));
+  handle->cf_cb = (uv_async_t*)uv__malloc(sizeof(*handle->cf_cb));
   if (handle->cf_cb == NULL) {
     err = UV_ENOMEM;
     goto fail_cf_cb_malloc;
@@ -841,7 +841,7 @@ int uv__fsevents_init(uv_fs_event_t* handle) {
     goto fail_cf_mutex_init;
 
   /* Insert handle into the list */
-  state = handle->loop->cf_state;
+  state = (uv__cf_loop_state_t*)handle->loop->cf_state;
   uv_mutex_lock(&state->fsevent_mutex);
   QUEUE_INSERT_TAIL(&state->fsevent_handles, &handle->cf_member);
   state->fsevent_handle_count++;
@@ -881,7 +881,7 @@ int uv__fsevents_close(uv_fs_event_t* handle) {
     return UV_EINVAL;
 
   /* Remove handle from  the list */
-  state = handle->loop->cf_state;
+  state = (uv__cf_loop_state_t*)handle->loop->cf_state;
   uv_mutex_lock(&state->fsevent_mutex);
   QUEUE_REMOVE(&handle->cf_member);
   state->fsevent_handle_count--;
diff --git a/src/unix/getaddrinfo.c b/src/unix/getaddrinfo.c
index 77337ace..41dc3909 100644
--- a/src/unix/getaddrinfo.c
+++ b/src/unix/getaddrinfo.c
@@ -172,7 +172,7 @@ int uv_getaddrinfo(uv_loop_t* loop,
   hostname_len = hostname ? strlen(hostname) + 1 : 0;
   service_len = service ? strlen(service) + 1 : 0;
   hints_len = hints ? sizeof(*hints) : 0;
-  buf = uv__malloc(hostname_len + service_len + hints_len);
+  buf = (char*)uv__malloc(hostname_len + service_len + hints_len);
 
   if (buf == NULL)
     return UV_ENOMEM;
@@ -190,17 +190,17 @@ int uv_getaddrinfo(uv_loop_t* loop,
   len = 0;
 
   if (hints) {
-    req->hints = memcpy(buf + len, hints, sizeof(*hints));
+    req->hints = (struct addrinfo*)memcpy(buf + len, hints, sizeof(*hints));
     len += sizeof(*hints);
   }
 
   if (service) {
-    req->service = memcpy(buf + len, service, service_len);
+    req->service = (char*)memcpy(buf + len, service, service_len);
     len += service_len;
   }
 
   if (hostname)
-    req->hostname = memcpy(buf + len, hostname, hostname_len);
+    req->hostname = (char*)memcpy(buf + len, hostname, hostname_len);
 
   if (cb) {
     uv__work_submit(loop,
diff --git a/src/unix/ibmi.c b/src/unix/ibmi.c
index 8c6ae636..56af31e9 100644
--- a/src/unix/ibmi.c
+++ b/src/unix/ibmi.c
@@ -288,7 +288,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
 
   numcpus = sysconf(_SC_NPROCESSORS_ONLN);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(uv_cpu_info_t));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(uv_cpu_info_t));
   if (!*cpu_infos) {
     return UV_ENOMEM;
   }
diff --git a/src/unix/kqueue.c b/src/unix/kqueue.c
index 5dac76ae..86eb529b 100644
--- a/src/unix/kqueue.c
+++ b/src/unix/kqueue.c
@@ -281,8 +281,8 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
     nevents = 0;
 
     assert(loop->watchers != NULL);
-    loop->watchers[loop->nwatchers] = (void*) events;
-    loop->watchers[loop->nwatchers + 1] = (void*) (uintptr_t) nfds;
+    loop->watchers[loop->nwatchers] = (uv__io_t*) events;
+    loop->watchers[loop->nwatchers + 1] = (uv__io_t*) (uintptr_t) nfds;
     for (i = 0; i < nfds; i++) {
       ev = events + i;
       fd = ev->ident;
@@ -304,7 +304,7 @@ void uv__io_poll(uv_loop_t* loop, int timeout) {
       /* Skip invalidated events, see uv__platform_invalidate_fd */
       if (fd == -1)
         continue;
-      w = loop->watchers[fd];
+      w = (uv__io_t*)loop->watchers[fd];
 
       if (w == NULL) {
         /* File descriptor that we've stopped watching, disarm it.
diff --git a/src/unix/linux-core.c b/src/unix/linux-core.c
index 23a7dafe..85f3fc01 100644
--- a/src/unix/linux-core.c
+++ b/src/unix/linux-core.c
@@ -117,7 +117,6 @@ void uv__platform_loop_delete(uv_loop_t* loop) {
 }
 
 
-
 uint64_t uv__hrtime(uv_clocktype_t type) {
   static clock_t fast_clock_id = -1;
   struct timespec t;
@@ -283,7 +282,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
     goto out;
 
   err = UV_ENOMEM;
-  ci = uv__calloc(numcpus, sizeof(*ci));
+  ci = (uv_cpu_info_t*)uv__calloc(numcpus, sizeof(*ci));
   if (ci == NULL)
     goto out;
 
@@ -663,7 +662,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
   }
 
   /* Make sure the memory is initiallized to zero using calloc() */
-  *addresses = uv__calloc(*count, sizeof(**addresses));
+  *addresses = (uv_interface_address_t*)uv__calloc(*count, sizeof(**addresses));
   if (!(*addresses)) {
     freeifaddrs(addrs);
     return UV_ENOMEM;
diff --git a/src/unix/linux-inotify.c b/src/unix/linux-inotify.c
index c1bd260e..f5366e96 100644
--- a/src/unix/linux-inotify.c
+++ b/src/unix/linux-inotify.c
@@ -281,12 +281,12 @@ int uv_fs_event_start(uv_fs_event_t* handle,
     goto no_insert;
 
   len = strlen(path) + 1;
-  w = uv__malloc(sizeof(*w) + len);
+  w = (watcher_list*)uv__malloc(sizeof(*w) + len);
   if (w == NULL)
     return UV_ENOMEM;
 
   w->wd = wd;
-  w->path = memcpy(w + 1, path, len);
+  w->path = (char*)memcpy(w + 1, path, len);
   QUEUE_INIT(&w->watchers);
   w->iterating = 0;
   RB_INSERT(watcher_root, CAST(&handle->loop->inotify_watchers), w);
diff --git a/src/unix/loop.c b/src/unix/loop.c
index a88e71c3..2e819cdd 100644
--- a/src/unix/loop.c
+++ b/src/unix/loop.c
@@ -148,7 +148,7 @@ int uv_loop_fork(uv_loop_t* loop) {
 
   /* Rearm all the watchers that aren't re-queued by the above. */
   for (i = 0; i < loop->nwatchers; i++) {
-    w = loop->watchers[i];
+    w = (uv__io_t*)loop->watchers[i];
     if (w == NULL)
       continue;
 
diff --git a/src/unix/netbsd.c b/src/unix/netbsd.c
index c66333f5..b6886a1c 100644
--- a/src/unix/netbsd.c
+++ b/src/unix/netbsd.c
@@ -206,14 +206,14 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
     cpuspeed = 0;
 
   size = numcpus * CPUSTATES * sizeof(*cp_times);
-  cp_times = uv__malloc(size);
+  cp_times = (u_int64_t*)uv__malloc(size);
   if (cp_times == NULL)
     return UV_ENOMEM;
 
   if (sysctlbyname("kern.cp_time", cp_times, &size, NULL, 0))
     return UV__ERR(errno);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos)) {
     uv__free(cp_times);
     uv__free(*cpu_infos);
diff --git a/src/unix/openbsd.c b/src/unix/openbsd.c
index f32a94df..62740f73 100644
--- a/src/unix/openbsd.c
+++ b/src/unix/openbsd.c
@@ -72,7 +72,7 @@ int uv_exepath(char* buffer, size_t* size) {
   mypid = getpid();
   for (;;) {
     err = UV_ENOMEM;
-    argsbuf = uv__reallocf(argsbuf, argsbuf_size);
+    argsbuf = (char**)uv__reallocf(argsbuf, argsbuf_size);
     if (argsbuf == NULL)
       goto out;
     mib[0] = CTL_KERN;
@@ -197,7 +197,7 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
   if (sysctl(which, ARRAY_SIZE(which), &numcpus, &size, NULL, 0))
     return UV__ERR(errno);
 
-  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));
+  *cpu_infos = (uv_cpu_info_t*)uv__malloc(numcpus * sizeof(**cpu_infos));
   if (!(*cpu_infos))
     return UV_ENOMEM;
 
diff --git a/src/unix/pipe.c b/src/unix/pipe.c
index e8cfa148..c8ba31da 100644
--- a/src/unix/pipe.c
+++ b/src/unix/pipe.c
@@ -309,7 +309,7 @@ int uv_pipe_pending_count(uv_pipe_t* handle) {
   if (handle->queued_fds == NULL)
     return 1;
 
-  queued_fds = handle->queued_fds;
+  queued_fds = (uv__stream_queued_fds_t*)(handle->queued_fds);
   return queued_fds->offset + 1;
 }
 
@@ -346,7 +346,7 @@ int uv_pipe_chmod(uv_pipe_t* handle, int mode) {
   if (r != UV_ENOBUFS)
     return r;
 
-  name_buffer = uv__malloc(name_len);
+  name_buffer = (char*)uv__malloc(name_len);
   if (name_buffer == NULL)
     return UV_ENOMEM;
 
diff --git a/src/unix/poll.c b/src/unix/poll.c
index 7a12e2d1..73647317 100644
--- a/src/unix/poll.c
+++ b/src/unix/poll.c
@@ -117,7 +117,7 @@ int uv_poll_stop(uv_poll_t* handle) {
 
 
 int uv_poll_start(uv_poll_t* handle, int pevents, uv_poll_cb poll_cb) {
-  uv__io_t** watchers;
+  void** watchers;
   uv__io_t* w;
   int events;
 
diff --git a/src/unix/posix-poll.c b/src/unix/posix-poll.c
index 0f4bf938..8da038d1 100644
--- a/src/unix/posix-poll.c
+++ b/src/unix/posix-poll.c
@@ -61,7 +61,7 @@ static void uv__pollfds_maybe_resize(uv_loop_t* loop) {
     return;
 
   n = loop->poll_fds_size ? loop->poll_fds_size * 2 : 64;
-  p = uv__reallocf(loop->poll_fds, n * sizeof(*loop->poll_fds));
+  p = (struct pollfd*)uv__reallocf(loop->poll_fds, n * sizeof(*loop->poll_fds));
   if (p == NULL)
     abort();
 
diff --git a/src/unix/process.c b/src/unix/process.c
index f8415368..0916aa45 100644
--- a/src/unix/process.c
+++ b/src/unix/process.c
@@ -403,7 +403,7 @@ static int posix_spawn_can_use_setsid;
 static void uv__spawn_init_posix_spawn_fncs(void) {
   /* Try to locate all non-portable functions at runtime */
   posix_spawn_fncs.file_actions.addchdir_np =
-    dlsym(RTLD_DEFAULT, "posix_spawn_file_actions_addchdir_np");
+    (int (*)(void* const*, const char*)) dlsym(RTLD_DEFAULT, "posix_spawn_file_actions_addchdir_np");
 }
 
 
@@ -967,7 +967,7 @@ int uv_spawn(uv_loop_t* loop,
   err = UV_ENOMEM;
   pipes = pipes_storage;
   if (stdio_count > (int) ARRAY_SIZE(pipes_storage))
-    pipes = uv__malloc(stdio_count * sizeof(*pipes));
+    pipes = (int (*)[2])uv__malloc(stdio_count * sizeof(*pipes));
 
   if (pipes == NULL)
     goto error;
diff --git a/src/unix/proctitle.c b/src/unix/proctitle.c
index 9d1f00dd..8cdec753 100644
--- a/src/unix/proctitle.c
+++ b/src/unix/proctitle.c
@@ -65,7 +65,7 @@ char** uv_setup_args(int argc, char** argv) {
   /* Add space for the argv pointers. */
   size += (argc + 1) * sizeof(char*);
 
-  new_argv = uv__malloc(size);
+  new_argv = (char**)uv__malloc(size);
   if (new_argv == NULL)
     return argv;
 
diff --git a/src/unix/random-sysctl-linux.c b/src/unix/random-sysctl-linux.c
index 66ba8d74..9ef18df0 100644
--- a/src/unix/random-sysctl-linux.c
+++ b/src/unix/random-sysctl-linux.c
@@ -48,7 +48,7 @@ int uv__random_sysctl(void* buf, size_t buflen) {
   char* pe;
   size_t n;
 
-  p = buf;
+  p = (char*)buf;
   pe = p + buflen;
 
   while (p < pe) {
diff --git a/src/unix/stream.c b/src/unix/stream.c
index b1f6359e..c6cc50e7 100644
--- a/src/unix/stream.c
+++ b/src/unix/stream.c
@@ -113,7 +113,7 @@ static void uv__stream_osx_interrupt_select(uv_stream_t* stream) {
   uv__stream_select_t* s;
   int r;
 
-  s = stream->select;
+  s = (uv__stream_select_t*)stream->select;
   if (s == NULL)
     return;
 
@@ -142,8 +142,8 @@ static void uv__stream_osx_select(void* arg) {
   int r;
   int max_fd;
 
-  stream = arg;
-  s = stream->select;
+  stream = (uv_stream_t*)arg;
+  s = (uv__stream_select_t*)stream->select;
   fd = s->fd;
 
   if (fd > s->int_fd)
@@ -320,7 +320,7 @@ int uv__stream_try_select(uv_stream_t* stream, int* fd) {
   sread_sz = ROUND_UP(max_fd + 1, sizeof(uint32_t) * NBBY) / NBBY;
   swrite_sz = sread_sz;
 
-  s = uv__malloc(sizeof(*s) + sread_sz + swrite_sz);
+  s = (uv__stream_select_t*)uv__malloc(sizeof(*s) + sread_sz + swrite_sz);
   if (s == NULL) {
     err = UV_ENOMEM;
     goto failed_malloc;
@@ -605,7 +605,7 @@ done:
   if (server->queued_fds != NULL) {
     uv__stream_queued_fds_t* queued_fds;
 
-    queued_fds = server->queued_fds;
+    queued_fds = (uv__stream_queued_fds_t*)(server->queued_fds);
 
     /* Read first */
     server->accepted_fd = queued_fds->fds[0];
@@ -844,7 +844,7 @@ static int uv__try_write(uv_stream_t* stream,
     /* silence aliasing warning */
     {
       void* pv = CMSG_DATA(cmsg);
-      int* pi = pv;
+      int* pi = (int*)pv;
       *pi = fd_to_send;
     }
 
@@ -975,11 +975,12 @@ static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {
   uv__stream_queued_fds_t* queued_fds;
   unsigned int queue_size;
 
-  queued_fds = stream->queued_fds;
+  queued_fds = (uv__stream_queued_fds_t*)stream->queued_fds;
   if (queued_fds == NULL) {
     queue_size = 8;
-    queued_fds = uv__malloc((queue_size - 1) * sizeof(*queued_fds->fds) +
-                            sizeof(*queued_fds));
+    queued_fds = (uv__stream_queued_fds_t*)
+        uv__malloc((queue_size - 1) * sizeof(*queued_fds->fds) +
+                   sizeof(*queued_fds));
     if (queued_fds == NULL)
       return UV_ENOMEM;
     queued_fds->size = queue_size;
@@ -989,9 +990,9 @@ static int uv__stream_queue_fd(uv_stream_t* stream, int fd) {
     /* Grow */
   } else if (queued_fds->size == queued_fds->offset) {
     queue_size = queued_fds->size + 8;
-    queued_fds = uv__realloc(queued_fds,
-                             (queue_size - 1) * sizeof(*queued_fds->fds) +
-                              sizeof(*queued_fds));
+    queued_fds = (uv__stream_queued_fds_t*)
+        uv__realloc(queued_fds, (queue_size - 1) * sizeof(*queued_fds->fds) +
+                    sizeof(*queued_fds));
 
     /*
      * Allocation failure, report back.
@@ -1039,7 +1040,7 @@ static int uv__stream_recv_cmsg(uv_stream_t* stream, struct msghdr* msg) {
 
     /* silence aliasing warning */
     pv = CMSG_DATA(cmsg);
-    pi = pv;
+    pi = (int*)pv;
 
     /* Count available fds */
     start = (char*) cmsg;
@@ -1423,7 +1424,7 @@ int uv_write2(uv_write_t* req,
 
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(bufs[0]));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(bufs[0]));
 
   if (req->bufs == NULL)
     return UV_ENOMEM;
@@ -1557,7 +1558,7 @@ int uv___stream_fd(const uv_stream_t* handle) {
          handle->type == UV_TTY ||
          handle->type == UV_NAMED_PIPE);
 
-  s = handle->select;
+  s = (const uv__stream_select_t*)handle->select;
   if (s != NULL)
     return s->fd;
 
@@ -1575,7 +1576,7 @@ void uv__stream_close(uv_stream_t* handle) {
   if (handle->select != NULL) {
     uv__stream_select_t* s;
 
-    s = handle->select;
+    s = (uv__stream_select_t*)handle->select;
 
     uv_sem_post(&s->close_sem);
     uv_sem_post(&s->async_sem);
@@ -1610,7 +1611,7 @@ void uv__stream_close(uv_stream_t* handle) {
 
   /* Close all queued fds */
   if (handle->queued_fds != NULL) {
-    queued_fds = handle->queued_fds;
+    queued_fds = (uv__stream_queued_fds_t*)(handle->queued_fds);
     for (i = 0; i < queued_fds->offset; i++)
       uv__close(queued_fds->fds[i]);
     uv__free(handle->queued_fds);
diff --git a/src/unix/thread.c b/src/unix/thread.c
index d89e5cd1..759cd0c2 100644
--- a/src/unix/thread.c
+++ b/src/unix/thread.c
@@ -59,7 +59,7 @@ int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {
   if (barrier == NULL || count == 0)
     return UV_EINVAL;
 
-  b = uv__malloc(sizeof(*b));
+  b = (_uv_barrier*)uv__malloc(sizeof(*b));
   if (b == NULL)
     return UV_ENOMEM;
 
@@ -275,8 +275,7 @@ int uv_thread_create_ex(uv_thread_t* tid,
       abort();
   }
 
-  f.in = entry;
-  err = pthread_create(tid, attr, f.out, arg);
+  err = pthread_create(tid, attr, (void*(*)(void*)) (void(*)(void)) entry, arg);
 
   if (attr != NULL)
     pthread_attr_destroy(attr);
@@ -547,7 +546,7 @@ static int uv__custom_sem_init(uv_sem_t* sem_, unsigned int value) {
   int err;
   uv_semaphore_t* sem;
 
-  sem = uv__malloc(sizeof(*sem));
+  sem = (uv_semaphore_t*)uv__malloc(sizeof(*sem));
   if (sem == NULL)
     return UV_ENOMEM;
 
diff --git a/src/unix/udp.c b/src/unix/udp.c
index 4d985b88..a130aeaa 100644
--- a/src/unix/udp.c
+++ b/src/unix/udp.c
@@ -227,11 +227,11 @@ static int uv__udp_recvmmsg(uv_udp_t* handle, uv_buf_t* buf) {
       if (msgs[k].msg_hdr.msg_flags & MSG_TRUNC)
         flags |= UV_UDP_PARTIAL;
 
-      chunk_buf = uv_buf_init(iov[k].iov_base, iov[k].iov_len);
+      chunk_buf = uv_buf_init((char*) iov[k].iov_base, iov[k].iov_len);
       handle->recv_cb(handle,
                       msgs[k].msg_len,
                       &chunk_buf,
-                      msgs[k].msg_hdr.msg_name,
+                      (const sockaddr*) msgs[k].msg_hdr.msg_name,
                       flags);
     }
 
@@ -281,7 +281,7 @@ static void uv__udp_recvmsg(uv_udp_t* handle) {
     memset(&peer, 0, sizeof(peer));
     h.msg_name = &peer;
     h.msg_namelen = sizeof(peer);
-    h.msg_iov = (void*) &buf;
+    h.msg_iov = (iovec*) &buf;
     h.msg_iovlen = 1;
 
     do {
@@ -765,7 +765,7 @@ int uv__udp_send(uv_udp_send_t* req,
 
   req->bufs = req->bufsml;
   if (nbufs > ARRAY_SIZE(req->bufsml))
-    req->bufs = uv__malloc(nbufs * sizeof(bufs[0]));
+    req->bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(bufs[0]));
 
   if (req->bufs == NULL) {
     uv__req_unregister(handle->loop, req);
diff --git a/src/uv-common.c b/src/uv-common.c
index efc9eb50..dfb606e3 100644
--- a/src/uv-common.c
+++ b/src/uv-common.c
@@ -54,10 +54,10 @@ static uv__allocator_t uv__allocator = {
 
 char* uv__strdup(const char* s) {
   size_t len = strlen(s) + 1;
-  char* m = uv__malloc(len);
+  char* m = (char*)uv__malloc(len);
   if (m == NULL)
     return NULL;
-  return memcpy(m, s, len);
+  return (char*)memcpy(m, s, len);
 }
 
 char* uv__strndup(const char* s, size_t n) {
@@ -65,11 +65,11 @@ char* uv__strndup(const char* s, size_t n) {
   size_t len = strlen(s);
   if (n < len)
     len = n;
-  m = uv__malloc(len + 1);
+  m = (char*)uv__malloc(len + 1);
   if (m == NULL)
     return NULL;
   m[len] = '\0';
-  return memcpy(m, s, len);
+  return (char*)memcpy(m, s, len);
 }
 
 void* uv__malloc(size_t size) {
@@ -653,7 +653,7 @@ void uv__fs_scandir_cleanup(uv_fs_t* req) {
 
   unsigned int* nbufs = uv__get_nbufs(req);
 
-  dents = req->ptr;
+  dents = (uv__dirent_t**)(req->ptr);
   if (*nbufs > 0 && *nbufs != (unsigned int) req->result)
     (*nbufs)--;
   for (; *nbufs < (unsigned int) req->result; (*nbufs)++)
@@ -680,7 +680,7 @@ int uv_fs_scandir_next(uv_fs_t* req, uv_dirent_t* ent) {
   nbufs = uv__get_nbufs(req);
   assert(nbufs);
 
-  dents = req->ptr;
+  dents = (uv__dirent_t**)(req->ptr);
 
   /* Free previous entity */
   if (*nbufs > 0)
@@ -745,7 +745,7 @@ void uv__fs_readdir_cleanup(uv_fs_t* req) {
   if (req->ptr == NULL)
     return;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   dirents = dir->dirents;
   req->ptr = NULL;
 
@@ -791,7 +791,7 @@ uv_loop_t* uv_default_loop(void) {
 uv_loop_t* uv_loop_new(void) {
   uv_loop_t* loop;
 
-  loop = uv__malloc(sizeof(*loop));
+  loop = (uv_loop_t*)uv__malloc(sizeof(*loop));
   if (loop == NULL)
     return NULL;
 
diff --git a/src/win/core.c b/src/win/core.c
index 67af93e6..0752edff 100644
--- a/src/win/core.c
+++ b/src/win/core.c
@@ -98,7 +98,8 @@ static int uv__loops_add(uv_loop_t* loop) {
 
   if (uv__loops_size == uv__loops_capacity) {
     new_capacity = uv__loops_capacity + UV__LOOPS_CHUNK_SIZE;
-    new_loops = uv__realloc(uv__loops, sizeof(uv_loop_t*) * new_capacity);
+    new_loops = (uv_loop_t**)
+        uv__realloc(uv__loops, sizeof(uv_loop_t*) * new_capacity);
     if (!new_loops)
       goto failed_loops_realloc;
     uv__loops = new_loops;
@@ -152,7 +153,8 @@ static void uv__loops_remove(uv_loop_t* loop) {
   smaller_capacity = uv__loops_capacity / 2;
   if (uv__loops_size >= smaller_capacity)
     goto loop_removed;
-  new_loops = uv__realloc(uv__loops, sizeof(uv_loop_t*) * smaller_capacity);
+  new_loops = (uv_loop_t**)
+      uv__realloc(uv__loops, sizeof(uv_loop_t*) * smaller_capacity);
   if (!new_loops)
     goto loop_removed;
   uv__loops = new_loops;
@@ -261,7 +263,7 @@ int uv_loop_init(uv_loop_t* loop) {
 
   loop->endgame_handles = NULL;
 
-  loop->timer_heap = timer_heap = uv__malloc(sizeof(*timer_heap));
+  loop->timer_heap = timer_heap = (heap*)uv__malloc(sizeof(*timer_heap));
   if (timer_heap == NULL) {
     err = UV_ENOMEM;
     goto fail_timers_alloc;
diff --git a/src/win/fs-event.c b/src/win/fs-event.c
index 6758c7c7..15046731 100644
--- a/src/win/fs-event.c
+++ b/src/win/fs-event.c
@@ -73,7 +73,7 @@ static void uv__relative_path(const WCHAR* filename,
   if (dirlen > 0 && dir[dirlen - 1] == '\\')
     dirlen--;
   relpathlen = filenamelen - dirlen - 1;
-  *relpath = uv__malloc((relpathlen + 1) * sizeof(WCHAR));
+  *relpath = (WCHAR*)uv__malloc((relpathlen + 1) * sizeof(WCHAR));
   if (!*relpath)
     uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
   wcsncpy(*relpath, filename + dirlen + 1, relpathlen);
@@ -242,7 +242,7 @@ int uv_fs_event_start(uv_fs_event_t* handle,
     if (short_path_buffer_len == 0) {
       goto short_path_done;
     }
-    short_path_buffer = uv__malloc(short_path_buffer_len * sizeof(WCHAR));
+    short_path_buffer = (WCHAR*)uv__malloc(short_path_buffer_len * sizeof(WCHAR));
     if (short_path_buffer == NULL) {
       goto short_path_done;
     }
diff --git a/src/win/fs-fd-hash-inl.h b/src/win/fs-fd-hash-inl.h
index 0b532af1..703a8d8f 100644
--- a/src/win/fs-fd-hash-inl.h
+++ b/src/win/fs-fd-hash-inl.h
@@ -146,7 +146,7 @@ INLINE static void uv__fd_hash_add(int fd, struct uv__fd_info_s* info) {
 
     if (bucket_ptr->size != 0 && i == 0) {
       struct uv__fd_hash_entry_group_s* new_group_ptr =
-        uv__malloc(sizeof(*new_group_ptr));
+        (struct uv__fd_hash_entry_group_s*)uv__malloc(sizeof(*new_group_ptr));
       if (new_group_ptr == NULL) {
         uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
       }
diff --git a/src/win/fs.c b/src/win/fs.c
index 79230799..8374012f 100644
--- a/src/win/fs.c
+++ b/src/win/fs.c
@@ -285,7 +285,7 @@ static int fs__wide_to_utf8(WCHAR* w_source_ptr,
     return 0;
   }
 
-  target = uv__malloc(target_len + 1);
+  target = (char*)uv__malloc(target_len + 1);
   if (target == NULL) {
     SetLastError(ERROR_OUTOFMEMORY);
     return -1;
@@ -1464,7 +1464,7 @@ void fs__scandir(uv_fs_t* req) {
       if (dirents_used >= dirents_size) {
         size_t new_dirents_size =
             dirents_size == 0 ? dirents_initial_size : dirents_size << 1;
-        uv__dirent_t** new_dirents =
+        uv__dirent_t** new_dirents = (uv__dirent_t**)
             uv__realloc(dirents, new_dirents_size * sizeof *dirents);
 
         if (new_dirents == NULL)
@@ -1478,7 +1478,7 @@ void fs__scandir(uv_fs_t* req) {
        * includes room for the first character of the filename, but `utf8_len`
        * doesn't count the NULL terminator at this point.
        */
-      dirent = uv__malloc(sizeof *dirent + utf8_len);
+      dirent = (uv__dirent_t*)uv__malloc(sizeof *dirent + utf8_len);
       if (dirent == NULL)
         goto out_of_memory_error;
 
@@ -1589,7 +1589,7 @@ void fs__opendir(uv_fs_t* req) {
     goto error;
   }
 
-  dir = uv__malloc(sizeof(*dir));
+  dir = (uv_dir_t*)uv__malloc(sizeof(*dir));
   if (dir == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
     goto error;
@@ -1604,7 +1604,7 @@ void fs__opendir(uv_fs_t* req) {
   else
     fmt = L"%s\\*";
 
-  find_path = uv__malloc(sizeof(WCHAR) * (len + 4));
+  find_path = (WCHAR*)uv__malloc(sizeof(WCHAR) * (len + 4));
   if (find_path == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
     goto error;
@@ -1641,7 +1641,7 @@ void fs__readdir(uv_fs_t* req) {
   int r;
 
   req->flags |= UV_FS_FREE_PTR;
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   dirents = dir->dirents;
   memset(dirents, 0, dir->nentries * sizeof(*dir->dirents));
   find_data = &dir->find_data;
@@ -1698,7 +1698,7 @@ error:
 void fs__closedir(uv_fs_t* req) {
   uv_dir_t* dir;
 
-  dir = req->ptr;
+  dir = (uv_dir_t*)req->ptr;
   FindClose(dir->dir_handle);
   uv__free(req->ptr);
   SET_REQ_RESULT(req, 0);
@@ -2627,7 +2627,7 @@ static ssize_t fs__realpath_handle(HANDLE handle, char** realpath_ptr) {
     return -1;
   }
 
-  w_realpath_buf = uv__malloc((w_realpath_len + 1) * sizeof(WCHAR));
+  w_realpath_buf = (WCHAR*)uv__malloc((w_realpath_len + 1) * sizeof(WCHAR));
   if (w_realpath_buf == NULL) {
     SetLastError(ERROR_OUTOFMEMORY);
     return -1;
@@ -2738,7 +2738,7 @@ retry_get_disk_free_space:
     }
 
     len = MAX_PATH + 1;
-    pathw = uv__malloc(len * sizeof(*pathw));
+    pathw = (WCHAR*)uv__malloc(len * sizeof(*pathw));
     if (pathw == NULL) {
       SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
       return;
@@ -2754,7 +2754,7 @@ retry_get_full_path_name:
       return;
     } else if (ret > len) {
       len = ret;
-      pathw = uv__reallocf(pathw, len * sizeof(*pathw));
+      pathw = (WCHAR*)uv__reallocf(pathw, len * sizeof(*pathw));
       if (pathw == NULL) {
         SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
         return;
@@ -2770,7 +2770,7 @@ retry_get_full_path_name:
     uv__free(pathw);
   }
 
-  stat_fs = uv__malloc(sizeof(*stat_fs));
+  stat_fs = (uv_statfs_t*)uv__malloc(sizeof(*stat_fs));
   if (stat_fs == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
     return;
@@ -2929,7 +2929,7 @@ int uv_fs_read(uv_loop_t* loop,
   req->fs.info.nbufs = nbufs;
   req->fs.info.bufs = req->fs.info.bufsml;
   if (nbufs > ARRAY_SIZE(req->fs.info.bufsml))
-    req->fs.info.bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->fs.info.bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->fs.info.bufs == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
@@ -2962,7 +2962,7 @@ int uv_fs_write(uv_loop_t* loop,
   req->fs.info.nbufs = nbufs;
   req->fs.info.bufs = req->fs.info.bufsml;
   if (nbufs > ARRAY_SIZE(req->fs.info.bufsml))
-    req->fs.info.bufs = uv__malloc(nbufs * sizeof(*bufs));
+    req->fs.info.bufs = (uv_buf_t*)uv__malloc(nbufs * sizeof(*bufs));
 
   if (req->fs.info.bufs == NULL) {
     SET_REQ_UV_ERROR(req, UV_ENOMEM, ERROR_OUTOFMEMORY);
diff --git a/src/win/pipe.c b/src/win/pipe.c
index 99846181..cd77061a 100644
--- a/src/win/pipe.c
+++ b/src/win/pipe.c
@@ -728,7 +728,7 @@ int uv_pipe_bind(uv_pipe_t* handle, const char* name) {
 
   /* Convert name to UTF16. */
   nameSize = MultiByteToWideChar(CP_UTF8, 0, name, -1, NULL, 0) * sizeof(WCHAR);
-  handle->name = uv__malloc(nameSize);
+  handle->name = (WCHAR*)uv__malloc(nameSize);
   if (!handle->name) {
     uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
   }
@@ -841,7 +841,7 @@ void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,
 
   /* Convert name to UTF16. */
   nameSize = MultiByteToWideChar(CP_UTF8, 0, name, -1, NULL, 0) * sizeof(WCHAR);
-  handle->name = uv__malloc(nameSize);
+  handle->name = (WCHAR*)uv__malloc(nameSize);
   if (!handle->name) {
     uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
   }
@@ -1453,7 +1453,7 @@ static int uv__build_coalesced_write_req(uv_write_t* user_req,
                        data_length;                  /* (c) */
 
   /* Allocate buffer. */
-  heap_buffer = uv__malloc(heap_buffer_length);
+  heap_buffer = (char*)uv__malloc(heap_buffer_length);
   if (heap_buffer == NULL)
     return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */
 
@@ -1698,7 +1698,7 @@ int uv__pipe_write_ipc(uv_loop_t* loop,
     bufs = stack_bufs;
   } else {
     /* Use heap-allocated buffer array. */
-    bufs = uv__calloc(buf_count, sizeof(uv_buf_t));
+    bufs = (uv_buf_t*)uv__calloc(buf_count, sizeof(uv_buf_t));
     if (bufs == NULL)
       return ERROR_NOT_ENOUGH_MEMORY; /* Maps to UV_ENOMEM. */
   }
@@ -2430,7 +2430,7 @@ static int uv__pipe_getname(const uv_pipe_t* handle, char* buffer, size_t* size)
                                       FileNameInformation);
   if (nt_status == STATUS_BUFFER_OVERFLOW) {
     name_size = sizeof(*name_info) + tmp_name_info.FileNameLength;
-    name_info = uv__malloc(name_size);
+    name_info = (FILE_NAME_INFORMATION*)uv__malloc(name_size);
     if (!name_info) {
       *size = 0;
       err = UV_ENOMEM;
diff --git a/src/win/process.c b/src/win/process.c
index 24c63339..e857db3e 100644
--- a/src/win/process.c
+++ b/src/win/process.c
@@ -616,8 +616,8 @@ error:
 
 
 int env_strncmp(const wchar_t* a, int na, const wchar_t* b) {
-  wchar_t* a_eq;
-  wchar_t* b_eq;
+  const wchar_t* a_eq;
+  const wchar_t* b_eq;
   wchar_t* A;
   wchar_t* B;
   int nb;
@@ -634,8 +634,8 @@ int env_strncmp(const wchar_t* a, int na, const wchar_t* b) {
   assert(b_eq);
   nb = b_eq - b;
 
-  A = alloca((na+1) * sizeof(wchar_t));
-  B = alloca((nb+1) * sizeof(wchar_t));
+  A = (wchar_t*)alloca((na+1) * sizeof(wchar_t));
+  B = (wchar_t*)alloca((nb+1) * sizeof(wchar_t));
 
   r = LCMapStringW(LOCALE_INVARIANT, LCMAP_UPPERCASE, a, na, A, na);
   assert(r==na);
@@ -718,7 +718,7 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
   if (dst_copy == NULL && env_len > 0) {
     return ERROR_OUTOFMEMORY;
   }
-  env_copy = alloca(env_block_count * sizeof(WCHAR*));
+  env_copy = (WCHAR**)alloca(env_block_count * sizeof(WCHAR*));
 
   ptr = dst_copy;
   ptr_copy = env_copy;
@@ -772,7 +772,7 @@ int make_program_env(char* env_block[], WCHAR** dst_ptr) {
   }
 
   /* final pass: copy, in sort order, and inserting required variables */
-  dst = uv__malloc((1+env_len) * sizeof(WCHAR));
+  dst = (WCHAR*)uv__malloc((1+env_len) * sizeof(WCHAR));
   if (!dst) {
     uv__free(dst_copy);
     return ERROR_OUTOFMEMORY;
diff --git a/src/win/tcp.c b/src/win/tcp.c
index b6aa4c51..4cccee42 100644
--- a/src/win/tcp.c
+++ b/src/win/tcp.c
@@ -612,7 +612,7 @@ int uv__tcp_listen(uv_tcp_t* handle, int backlog, uv_connection_cb cb) {
 
   if (handle->tcp.serv.accept_reqs == NULL) {
     handle->tcp.serv.accept_reqs =
-      uv__malloc(uv_simultaneous_server_accepts * sizeof(uv_tcp_accept_t));
+      (uv_tcp_accept_t*)uv__malloc(uv_simultaneous_server_accepts * sizeof(uv_tcp_accept_t));
     if (!handle->tcp.serv.accept_reqs) {
       uv_fatal_error(ERROR_OUTOFMEMORY, "uv__malloc");
     }
diff --git a/src/win/thread.c b/src/win/thread.c
index d3b1c96b..9ad60c91 100644
--- a/src/win/thread.c
+++ b/src/win/thread.c
@@ -98,7 +98,7 @@ static UINT __stdcall uv__thread_start(void* arg) {
   struct thread_ctx *ctx_p;
   struct thread_ctx ctx;
 
-  ctx_p = arg;
+  ctx_p = (struct thread_ctx*)arg;
   ctx = *ctx_p;
   uv__free(ctx_p);
 
@@ -141,7 +141,7 @@ int uv_thread_create_ex(uv_thread_t* tid,
       return UV_EINVAL;
   }
 
-  ctx = uv__malloc(sizeof(*ctx));
+  ctx = (struct thread_ctx*)uv__malloc(sizeof(*ctx));
   if (ctx == NULL)
     return UV_ENOMEM;
 
diff --git a/src/win/util.c b/src/win/util.c
index 99432053..c655f532 100644
--- a/src/win/util.c
+++ b/src/win/util.c
@@ -164,7 +164,7 @@ int uv_cwd(char* buffer, size_t* size) {
   if (utf16_len == 0) {
     return uv_translate_sys_error(GetLastError());
   }
-  utf16_buffer = uv__malloc(utf16_len * sizeof(WCHAR));
+  utf16_buffer = (WCHAR*)uv__malloc(utf16_len * sizeof(WCHAR));
   if (utf16_buffer == NULL) {
     return UV_ENOMEM;
   }
@@ -242,7 +242,7 @@ int uv_chdir(const char* dir) {
   if (utf16_len == 0) {
     return uv_translate_sys_error(GetLastError());
   }
-  utf16_buffer = uv__malloc(utf16_len * sizeof(WCHAR));
+  utf16_buffer = (WCHAR*)uv__malloc(utf16_len * sizeof(WCHAR));
   if (utf16_buffer == NULL) {
     return UV_ENOMEM;
   }
@@ -268,7 +268,7 @@ int uv_chdir(const char* dir) {
   new_utf16_len = GetCurrentDirectoryW(utf16_len, utf16_buffer);
   if (new_utf16_len > utf16_len ) {
     uv__free(utf16_buffer);
-    utf16_buffer = uv__malloc(new_utf16_len * sizeof(WCHAR));
+    utf16_buffer = (WCHAR*)uv__malloc(new_utf16_len * sizeof(WCHAR));
     if (utf16_buffer == NULL) {
       /* When updating the environment variable fails, return UV_OK anyway.
        * We did successfully change current working directory, only updating
@@ -573,14 +573,14 @@ int uv_cpu_info(uv_cpu_info_t** cpu_infos_ptr, int* cpu_count_ptr) {
   GetSystemInfo(&system_info);
   cpu_count = system_info.dwNumberOfProcessors;
 
-  cpu_infos = uv__calloc(cpu_count, sizeof *cpu_infos);
+  cpu_infos = (uv_cpu_info_t*)uv__calloc(cpu_count, sizeof *cpu_infos);
   if (cpu_infos == NULL) {
     err = ERROR_OUTOFMEMORY;
     goto error;
   }
 
   sppi_size = cpu_count * sizeof(*sppi);
-  sppi = uv__malloc(sppi_size);
+  sppi = (SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION*)uv__malloc(sppi_size);
   if (sppi == NULL) {
     err = ERROR_OUTOFMEMORY;
     goto error;
@@ -802,7 +802,8 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
       case ERROR_BUFFER_OVERFLOW:
         /* This happens when win_address_buf is NULL or too small to hold all
          * adapters. */
-        win_address_buf = uv__malloc(win_address_buf_size);
+        win_address_buf =
+            (IP_ADAPTER_ADDRESSES*)uv__malloc(win_address_buf_size);
         if (win_address_buf == NULL)
           return UV_ENOMEM;
 
@@ -810,7 +811,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
 
       case ERROR_NO_DATA: {
         /* No adapters were found. */
-        uv_address_buf = uv__malloc(1);
+        uv_address_buf = (uv_interface_address_t*)uv__malloc(1);
         if (uv_address_buf == NULL)
           return UV_ENOMEM;
 
@@ -887,7 +888,7 @@ int uv_interface_addresses(uv_interface_address_t** addresses_ptr,
   }
 
   /* Allocate space to store interface data plus adapter names. */
-  uv_address_buf = uv__malloc(uv_address_buf_size);
+  uv_address_buf = (uv_interface_address_t*)uv__malloc(uv_address_buf_size);
   if (uv_address_buf == NULL) {
     uv__free(win_address_buf);
     return UV_ENOMEM;
@@ -1131,7 +1132,7 @@ int uv_os_tmpdir(char* buffer, size_t* size) {
   }
   /* Include space for terminating null char. */
   len += 1;
-  path = uv__malloc(len * sizeof(wchar_t));
+  path = (wchar_t*)uv__malloc(len * sizeof(wchar_t));
   if (path == NULL) {
     return UV_ENOMEM;
   }
@@ -1221,7 +1222,7 @@ int uv__convert_utf16_to_utf8(const WCHAR* utf16, int utf16len, char** utf8) {
   /* Allocate the destination buffer adding an extra byte for the terminating
    * NULL. If utf16len is not -1 WideCharToMultiByte will not add it, so
    * we do it ourselves always, just in case. */
-  *utf8 = uv__malloc(bufsize + 1);
+  *utf8 = (char*)uv__malloc(bufsize + 1);
 
   if (*utf8 == NULL)
     return UV_ENOMEM;
@@ -1269,7 +1270,7 @@ int uv__convert_utf8_to_utf16(const char* utf8, int utf8len, WCHAR** utf16) {
   /* Allocate the destination buffer adding an extra byte for the terminating
    * NULL. If utf8len is not -1 MultiByteToWideChar will not add it, so
    * we do it ourselves always, just in case. */
-  *utf16 = uv__malloc(sizeof(WCHAR) * (bufsize + 1));
+  *utf16 = (WCHAR*)uv__malloc(sizeof(WCHAR) * (bufsize + 1));
 
   if (*utf16 == NULL)
     return UV_ENOMEM;
@@ -1310,7 +1311,7 @@ int uv__getpwuid_r(uv_passwd_t* pwd) {
     return uv_translate_sys_error(r);
   }
 
-  path = uv__malloc(bufsize * sizeof(wchar_t));
+  path = (wchar_t*)uv__malloc(bufsize * sizeof(wchar_t));
   if (path == NULL) {
     CloseHandle(token);
     return UV_ENOMEM;
@@ -1381,7 +1382,7 @@ int uv_os_environ(uv_env_item_t** envitems, int* count) {
 
   for (penv = env, i = 0; *penv != L'\0'; penv += wcslen(penv) + 1, i++);
 
-  *envitems = uv__calloc(i, sizeof(**envitems));
+  *envitems = (uv_env_item_t*)uv__calloc(i, sizeof(**envitems));
   if (*envitems == NULL) {
     FreeEnvironmentStringsW(env);
     return UV_ENOMEM;
@@ -1471,7 +1472,7 @@ int uv_os_getenv(const char* name, char* buffer, size_t* size) {
       uv__free(var);
 
     varlen = 1 + len;
-    var = uv__malloc(varlen * sizeof(*var));
+    var = (wchar_t*)uv__malloc(varlen * sizeof(*var));
 
     if (var == NULL) {
       r = UV_ENOMEM;
