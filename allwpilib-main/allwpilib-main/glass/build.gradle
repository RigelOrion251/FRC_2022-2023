import org.gradle.internal.os.OperatingSystem

if (!project.hasProperty('onlylinuxathena')) {

    description = "A different kind of dashboard"

    apply plugin: 'cpp'
    apply plugin: 'c'
    apply plugin: 'google-test-test-suite'
    apply plugin: 'visual-studio'
    apply plugin: 'edu.wpi.first.NativeUtils'

    if (OperatingSystem.current().isWindows()) {
        apply plugin: 'windows-resources'
    }

    ext {
        nativeName = 'glass'
    }

    apply from: "${rootDir}/shared/resources.gradle"
    apply from: "${rootDir}/shared/config.gradle"

    def wpilibVersionFileInput = file("src/app/generate/WPILibVersion.cpp.in")
    def wpilibVersionFileOutput = file("$buildDir/generated/app/cpp/WPILibVersion.cpp")

    apply from: "${rootDir}/shared/imgui.gradle"

    task generateCppVersion() {
        description = 'Generates the wpilib version class'
        group = 'WPILib'

        outputs.file wpilibVersionFileOutput
        inputs.file wpilibVersionFileInput

        if (wpilibVersioning.releaseMode) {
            outputs.upToDateWhen { false }
        }

        // We follow a simple set of checks to determine whether we should generate a new version file:
        // 1. If the release type is not development, we generate a new version file
        // 2. If there is no generated version number, we generate a new version file
        // 3. If there is a generated build number, and the release type is development, then we will
        //    only generate if the publish task is run.
        doLast {
            def version = wpilibVersioning.version.get()
            println "Writing version ${version} to $wpilibVersionFileOutput"

            if (wpilibVersionFileOutput.exists()) {
                wpilibVersionFileOutput.delete()
            }
            def read = wpilibVersionFileInput.text.replace('${wpilib_version}', version)
            wpilibVersionFileOutput.write(read)
        }
    }

    gradle.taskGraph.addTaskExecutionGraphListener { graph ->
        def willPublish = graph.hasTask(publish)
        if (willPublish) {
            generateCppVersion.outputs.upToDateWhen { false }
        }
    }

    def generateTask = createGenerateResourcesTask('app', 'GLASS', 'glass', project)

    project(':').libraryBuild.dependsOn build
    tasks.withType(CppCompile) {
        dependsOn generateTask
        dependsOn generateCppVersion
    }

    nativeUtils.exportsConfigs {
        glass {
            x64ExcludeSymbols = [
                '_CT??_R0?AV_System_error',
                '_CT??_R0?AVexception',
                '_CT??_R0?AVfailure',
                '_CT??_R0?AVruntime_error',
                '_CT??_R0?AVsystem_error',
                '_CTA5?AVfailure',
                '_TI5?AVfailure',
                '_CT??_R0?AVout_of_range',
                '_CTA3?AVout_of_range',
                '_TI3?AVout_of_range',
                '_CT??_R0?AVbad_cast'
            ]
        }
    }

    model {
        components {
            "${nativeName}"(NativeLibrarySpec) {
                sources {
                    cpp {
                        source {
                            srcDirs 'src/lib/native/cpp'
                            include '**/*.cpp'
                        }
                        exportedHeaders {
                            srcDirs 'src/lib/native/include'
                        }
                    }
                }
                binaries.all {
                    if (it.targetPlatform.name == nativeUtils.wpi.platforms.roborio) {
                        it.buildable = false
                        return
                    }
                    if (it instanceof SharedLibraryBinarySpec) {
                        it.buildable = false
                        return
                    }
                    lib project: ':wpiutil', library: 'wpiutil', linkage: 'shared'
                    lib project: ':wpimath', library: 'wpimath', linkage: 'shared'
                    lib project: ':wpigui', library: 'wpigui', linkage: 'static'
                    nativeUtils.useRequiredLibrary(it, 'imgui')
                }
                appendDebugPathToBinaries(binaries)
            }
            "${nativeName}nt"(NativeLibrarySpec) {
                sources {
                    cpp {
                        source {
                            srcDirs = ['src/libnt/native/cpp']
                            include '**/*.cpp'
                        }
                        exportedHeaders {
                            srcDirs 'src/libnt/native/include'
                        }
                    }
                }
                binaries.all {
                    if (it.targetPlatform.name == nativeUtils.wpi.platforms.roborio) {
                        it.buildable = false
                        return
                    }
                    if (it instanceof SharedLibraryBinarySpec) {
                        it.buildable = false
                        return
                    }
                    lib library: nativeName, linkage: 'static'
                    project(':ntcore').addNtcoreDependency(it, 'shared')
                    lib project: ':wpinet', library: 'wpinet', linkage: 'shared'
                    lib project: ':wpiutil', library: 'wpiutil', linkage: 'shared'
                    lib project: ':wpimath', library: 'wpimath', linkage: 'shared'
                    lib project: ':wpigui', library: 'wpigui', linkage: 'static'
                    nativeUtils.useRequiredLibrary(it, 'imgui')
                }
                appendDebugPathToBinaries(binaries)
            }
            // By default, a development executable will be generated. This is to help the case of
            // testing specific functionality of the library.
            "${nativeName}App"(NativeExecutableSpec) {
                baseName = 'glass'
                sources {
                    cpp {
                        source {
                            srcDirs 'src/app/native/cpp', "$buildDir/generated/app/cpp"
                            include '**/*.cpp'
                        }
                        exportedHeaders {
                            srcDirs 'src/app/native/include'
                        }
                    }
                    if (OperatingSystem.current().isWindows()) {
                        rc {
                            source {
                                srcDirs 'src/app/native/win'
                            }
                        }
                    }
                }
                binaries.all {
                    if (it.targetPlatform.name == nativeUtils.wpi.platforms.roborio) {
                        it.buildable = false
                        return
                    }
                    lib project: ':cscore', library: 'cscore', linkage: 'static'
                    lib library: 'glassnt', linkage: 'static'
                    lib library: nativeName, linkage: 'static'
                    project(':ntcore').addNtcoreDependency(it, 'static')
                    lib project: ':wpinet', library: 'wpinet', linkage: 'static'
                    lib project: ':wpiutil', library: 'wpiutil', linkage: 'static'
                    lib project: ':wpimath', library: 'wpimath', linkage: 'static'
                    lib project: ':wpigui', library: 'wpigui', linkage: 'static'
                    nativeUtils.useRequiredLibrary(it, 'opencv_static')
                    nativeUtils.useRequiredLibrary(it, 'imgui')
                    if (it.targetPlatform.operatingSystem.isWindows()) {
                        it.linker.args << 'Gdi32.lib' << 'Shell32.lib' << 'd3d11.lib' << 'd3dcompiler.lib'
                        it.linker.args << '/DELAYLOAD:MF.dll' << '/DELAYLOAD:MFReadWrite.dll' << '/DELAYLOAD:MFPlat.dll' << '/delay:nobind'
                    } else if (it.targetPlatform.operatingSystem.isMacOsX()) {
                        it.linker.args << '-framework' << 'Metal' << '-framework' << 'MetalKit' << '-framework' << 'Cocoa' << '-framework' << 'IOKit' << '-framework' << 'CoreFoundation' << '-framework' << 'CoreVideo' << '-framework' << 'QuartzCore'
                    } else {
                        it.linker.args << '-lX11'
                        if (it.targetPlatform.name.startsWith('linuxarm')) {
                            it.linker.args << '-lGL'
                        }
                    }
                }
            }
        }
    }

    apply from: 'publish.gradle'
}
